"""
Indicates that an Input Object is a OneOf Input Object (and thus requires
                        exactly one of its field be provided)
"""
directive @oneOf on INPUT_OBJECT

type Account implements Entity {
  id: AccountId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  run_id: RunId
  tags: [String!]
  tier: AccountTier!
  config: AccountConfig
  source_run: Run
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  object_descriptor(id: ObjectDescriptorId!): ObjectDescriptor!
  project(id: ProjectId!): Project!
  argument(id: ArgumentId!): Argument!
  module_instances(after: String, before: String, first: Int, last: Int, filter: ModuleInstanceFilter, sort: ModuleInstanceSort): ModuleInstanceConnection!
  arguments(after: String, before: String, first: Int, last: Int, filter: ArgumentFilter, sort: ArgumentSort): ArgumentConnection!
  credits(after: String, before: String, first: Int, last: Int, filter: CreditFilter, sort: CreditSort): CreditConnection!
  object_descriptors(after: String, before: String, first: Int, last: Int, filter: ObjectDescriptorFilter, sort: ObjectDescriptorSort): ObjectDescriptorConnection!
  projects(after: String, before: String, first: Int, last: Int, filter: ProjectFilter, sort: ProjectSort): ProjectConnection!
  credit_balance: CreditReport!
  resource_utilization(from: DateTime, to: DateTime): [ResourceUtilizationReport!]!
  module_instance_tags(after: String, before: String, first: Int, last: Int, order: OrderBy, contains: String, min_count: Int): V1TagConnection!
}

type AccountBucketConfig {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

input AccountBucketConfigInput {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

type AccountConfig {
  config_account: AccountId
  bucket_config: AccountBucketConfig
}

input AccountConfigInput {
  config_account: AccountId
  bucket_config: AccountBucketConfigInput
}

scalar AccountId

enum AccountTier {
  FREE
  PRO
  STARTUP
  ACADEMIC
  ENTERPRISE
}

"""
The SAR models can predict any sort of ground truth value, i.e. "Activity"
NOTE: async_graphql automatically converts enum values to SCREAMING_CAMEL_CASE,
so e.g. in graphql you'll need to pass BINDING_AFFINITY, TOXICITY, or FUNCTIONAL.
This doesn't affect the way the values are stored in the db, i.e. as lowercase.
"""
enum ActivityType {
  BINDING_AFFINITY
  TOXICITY
  FUNCTIONAL
}

input ActivityTypeFilter {
  eq: ActivityType
  ne: ActivityType
}

type Answer {
  content: [Content!]!
}

input AnswerInput {
  content: [ContentInput!]!
}

type Argument {
  id: ArgumentId!
  rejected_at: DateTime
  resolved_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  source: ModuleInstanceId

  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
}

type ArgumentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ArgumentEdge!]!

  """A list of nodes."""
  nodes: [Argument!]!
  total_count: Int!
}

"""An edge in a connection."""
type ArgumentEdge {
  """The item at the end of the edge"""
  node: Argument!

  """A cursor for use in pagination"""
  cursor: String!
}

input ArgumentFilter {
  all: [ArgumentFilter!]
  any: [ArgumentFilter!]
  id: UuidFilter
  rejected_at: DateTimeFilter
  resolved_at: DateTimeFilter
  account_id: UuidFilter
  source: UuidFilter
  metadata: MetadataFilter
}

scalar ArgumentId

input ArgumentInput {
  id: ArgumentId
  name: String
  tags: [String!]
  value: JSON
}

input ArgumentSort {
  id: UuidSort
  rejected_at: DateTimeSort
  resolved_at: DateTimeSort
  account_id: UuidSort
  metadata: MetadataSort
}

scalar AtomRef

type Benchmark implements Entity {
  id: BenchmarkId!
  evaluation_script: String
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  data(after: String, before: String, first: Int, last: Int, filter: BenchmarkDataFilter, sort: BenchmarkDataSort): BenchmarkDataConnection!
  submissions(after: String, before: String, first: Int, last: Int, filter: BenchmarkSubmissionFilter): BenchmarkSubmissionConnection!
}

type BenchmarkArg {
  entity: BenchmarkEntityType!
  id: UUID!
}

input BenchmarkArgInput {
  entity: BenchmarkEntityType!
  id: UUID!
}

type BenchmarkConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkEdge!]!

  """A list of nodes."""
  nodes: [Benchmark!]!
  total_count: Int!
}

type BenchmarkData implements Entity {
  id: BenchmarkDataId!
  inputs: [BenchmarkArg!]!
  outputs: [BenchmarkArg!]!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  benchmark: Benchmark!
  input_entities: [Entity!]!
  output_entities: [Entity!]!
}

type BenchmarkDataConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkDataEdge!]!

  """A list of nodes."""
  nodes: [BenchmarkData!]!
  total_count: Int!
}

"""An edge in a connection."""
type BenchmarkDataEdge {
  """The item at the end of the edge"""
  node: BenchmarkData!

  """A cursor for use in pagination"""
  cursor: String!
}

input BenchmarkDataFilter {
  all: [BenchmarkDataFilter!]
  any: [BenchmarkDataFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  benchmark_id: UuidFilter
}

scalar BenchmarkDataId

input BenchmarkDataSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  benchmark_id: UuidSort
}

"""An edge in a connection."""
type BenchmarkEdge {
  """The item at the end of the edge"""
  node: Benchmark!

  """A cursor for use in pagination"""
  cursor: String!
}

enum BenchmarkEntityType {
  PROTEIN
  PROTEIN_CONFORMER
  SMOL
  STRUCTURE
  BINDING_AFFINITY
}

input BenchmarkFilter {
  all: [BenchmarkFilter!]
  any: [BenchmarkFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  evaluation_script: StringFilter
}

scalar BenchmarkId

input BenchmarkSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

type BenchmarkSubmission implements Entity {
  id: BenchmarkSubmissionId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  benchmark: Benchmark!
  scores(after: String, before: String, first: Int, last: Int, filter: BenchmarkSubmissionScoreFilter, sort: BenchmarkSubmissionScoreSort): BenchmarkSubmissionScoreConnection!
  data(after: String, before: String, first: Int, last: Int, filter: BenchmarkSubmissionDataFilter, sort: BenchmarkSubmissionDataSort): BenchmarkSubmissionDataConnection!
}

type BenchmarkSubmissionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkSubmissionEdge!]!

  """A list of nodes."""
  nodes: [BenchmarkSubmission!]!
  total_count: Int!
}

type BenchmarkSubmissionData implements Entity {
  id: BenchmarkSubmissionDataId!
  outputs: [BenchmarkArg!]!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  benchmark_data: BenchmarkData!
  benchmark_submission: BenchmarkSubmission!
  scores(after: String, before: String, first: Int, last: Int, filter: BenchmarkSubmissionDataScoreFilter, sort: BenchmarkSubmissionDataScoreSort): BenchmarkSubmissionDataScoreConnection!
  output_entities: [Entity!]!
}

type BenchmarkSubmissionDataConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkSubmissionDataEdge!]!

  """A list of nodes."""
  nodes: [BenchmarkSubmissionData!]!
  total_count: Int!
}

"""An edge in a connection."""
type BenchmarkSubmissionDataEdge {
  """The item at the end of the edge"""
  node: BenchmarkSubmissionData!

  """A cursor for use in pagination"""
  cursor: String!
}

input BenchmarkSubmissionDataFilter {
  all: [BenchmarkSubmissionDataFilter!]
  any: [BenchmarkSubmissionDataFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  benchmark_data_id: UuidFilter
  benchmark_submission_id: UuidFilter
}

scalar BenchmarkSubmissionDataId

type BenchmarkSubmissionDataScore {
  id: BenchmarkSubmissionDataScoreId!
  score: Float!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  benchmark_submission_data: BenchmarkSubmissionData!
}

type BenchmarkSubmissionDataScoreConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkSubmissionDataScoreEdge!]!

  """A list of nodes."""
  nodes: [BenchmarkSubmissionDataScore!]!
  total_count: Int!
}

"""An edge in a connection."""
type BenchmarkSubmissionDataScoreEdge {
  """The item at the end of the edge"""
  node: BenchmarkSubmissionDataScore!

  """A cursor for use in pagination"""
  cursor: String!
}

input BenchmarkSubmissionDataScoreFilter {
  all: [BenchmarkSubmissionDataScoreFilter!]
  any: [BenchmarkSubmissionDataScoreFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  score: F64Filter
  benchmark_submission_data_id: UuidFilter
}

scalar BenchmarkSubmissionDataScoreId

input BenchmarkSubmissionDataScoreSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  score: F64Sort
  benchmark_submission_data_id: UuidSort
}

input BenchmarkSubmissionDataSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  benchmark_data_id: UuidSort
  benchmark_submission_id: UuidSort
}

"""An edge in a connection."""
type BenchmarkSubmissionEdge {
  """The item at the end of the edge"""
  node: BenchmarkSubmission!

  """A cursor for use in pagination"""
  cursor: String!
}

input BenchmarkSubmissionFilter {
  all: [BenchmarkSubmissionFilter!]
  any: [BenchmarkSubmissionFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  benchmark_id: UuidFilter
}

scalar BenchmarkSubmissionId

type BenchmarkSubmissionScore {
  id: BenchmarkSubmissionScoreId!
  score: Float!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  benchmark_submission: BenchmarkSubmission!
}

type BenchmarkSubmissionScoreConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BenchmarkSubmissionScoreEdge!]!

  """A list of nodes."""
  nodes: [BenchmarkSubmissionScore!]!
  total_count: Int!
}

"""An edge in a connection."""
type BenchmarkSubmissionScoreEdge {
  """The item at the end of the edge"""
  node: BenchmarkSubmissionScore!

  """A cursor for use in pagination"""
  cursor: String!
}

input BenchmarkSubmissionScoreFilter {
  all: [BenchmarkSubmissionScoreFilter!]
  any: [BenchmarkSubmissionScoreFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  score: F64Filter
  benchmark_submission_id: UuidFilter
}

scalar BenchmarkSubmissionScoreId

input BenchmarkSubmissionScoreSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  score: F64Sort
  benchmark_submission_id: UuidSort
}

input BenchmarkSubmissionSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  benchmark_id: UuidSort
}

type BindingAffinity implements Entity {
  id: BindingAffinityId!
  affinity: Float!
  affinity_metric: String!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein: Protein!
  smol: Smol!
  binding_pose_affinities(after: String, before: String, first: Int, last: Int, filter: BindingPoseAffinityFilter, sort: BindingPoseAffinitySort): BindingPoseAffinityConnection!
  binding_affinity_activities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityActivityFilter, sort: BindingAffinityActivitySort): BindingAffinityActivityConnection!
}

type BindingAffinityActivity implements Entity {
  id: BindingAffinityActivityId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  sar_program: SarProgram!
  binding_affinity: BindingAffinity!
}

type BindingAffinityActivityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingAffinityActivityEdge!]!

  """A list of nodes."""
  nodes: [BindingAffinityActivity!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingAffinityActivityEdge {
  """The item at the end of the edge"""
  node: BindingAffinityActivity!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingAffinityActivityFilter {
  all: [BindingAffinityActivityFilter!]
  any: [BindingAffinityActivityFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  sar_program_id: UuidFilter
  binding_affinity_id: UuidFilter
}

scalar BindingAffinityActivityId

input BindingAffinityActivitySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  sar_program_id: UuidSort
  binding_affinity_id: UuidSort
}

type BindingAffinityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingAffinityEdge!]!

  """A list of nodes."""
  nodes: [BindingAffinity!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingAffinityEdge {
  """The item at the end of the edge"""
  node: BindingAffinity!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingAffinityFilter {
  all: [BindingAffinityFilter!]
  any: [BindingAffinityFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  affinity: F64Filter
  affinity_metric: StringFilter
  protein_id: UuidFilter
  smol_id: UuidFilter
}

scalar BindingAffinityId

input BindingAffinitySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  affinity: F64Sort
  affinity_metric: StringSort
  protein_id: UuidSort
  smol_id: UuidSort
}

type BindingPoseAffinity implements Entity {
  id: BindingPoseAffinityId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  binding_affinity: BindingAffinity!
  binding_pose_conformer: BindingPoseConformer!
}

type BindingPoseAffinityConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingPoseAffinityEdge!]!

  """A list of nodes."""
  nodes: [BindingPoseAffinity!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingPoseAffinityEdge {
  """The item at the end of the edge"""
  node: BindingPoseAffinity!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingPoseAffinityFilter {
  all: [BindingPoseAffinityFilter!]
  any: [BindingPoseAffinityFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  binding_affinity_id: UuidFilter
  binding_pose_conformer_id: UuidFilter
}

scalar BindingPoseAffinityId

input BindingPoseAffinitySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  binding_affinity_id: UuidSort
  binding_pose_conformer_id: UuidSort
}

type BindingPoseConformer implements Entity {
  id: BindingPoseConformerId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  smol_conformer: SmolConformer!
  binding_site_conformer: BindingSiteConformer!
  binding_pose_affinities(after: String, before: String, first: Int, last: Int, filter: BindingPoseAffinityFilter, sort: BindingPoseAffinitySort): BindingPoseAffinityConnection!
  binding_pose_conformer_interactions(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerInteractionsFilter, sort: BindingPoseConformerInteractionsSort): BindingPoseConformerInteractionsConnection!
}

type BindingPoseConformerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingPoseConformerEdge!]!

  """A list of nodes."""
  nodes: [BindingPoseConformer!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingPoseConformerEdge {
  """The item at the end of the edge"""
  node: BindingPoseConformer!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingPoseConformerFilter {
  all: [BindingPoseConformerFilter!]
  any: [BindingPoseConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smol_conformer_id: UuidFilter
  binding_site_conformer_id: UuidFilter
}

scalar BindingPoseConformerId

type BindingPoseConformerInteractions implements Entity {
  id: BindingPoseConformerInteractionsId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  binding_pose_conformer: BindingPoseConformer!
  binding_site_interactions: BindingSiteInteractions!
}

type BindingPoseConformerInteractionsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingPoseConformerInteractionsEdge!]!

  """A list of nodes."""
  nodes: [BindingPoseConformerInteractions!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingPoseConformerInteractionsEdge {
  """The item at the end of the edge"""
  node: BindingPoseConformerInteractions!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingPoseConformerInteractionsFilter {
  all: [BindingPoseConformerInteractionsFilter!]
  any: [BindingPoseConformerInteractionsFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  binding_pose_conformer_id: UuidFilter
  binding_site_interactions_id: UuidFilter
}

scalar BindingPoseConformerInteractionsId

input BindingPoseConformerInteractionsSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  binding_pose_conformer_id: UuidSort
  binding_site_interactions_id: UuidSort
}

input BindingPoseConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smol_conformer_id: UuidSort
  binding_site_conformer_id: UuidSort
}

type BindingSiteBoundingBox {
  min: Xyzf32!
  max: Xyzf32!
}

input BindingSiteBoundingBoxInput {
  min: Xyzf32!
  max: Xyzf32!
}

type BindingSiteConformer implements Entity {
  id: BindingSiteConformerId!
  bounding_box: BindingSiteBoundingBox!
  surface_atoms: [Int!]
  score: Float
  probability: Float
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein_conformer: ProteinConformer!
  binding_pose_conformers(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerFilter, sort: BindingPoseConformerSort): BindingPoseConformerConnection!
}

type BindingSiteConformerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingSiteConformerEdge!]!

  """A list of nodes."""
  nodes: [BindingSiteConformer!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingSiteConformerEdge {
  """The item at the end of the edge"""
  node: BindingSiteConformer!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingSiteConformerFilter {
  all: [BindingSiteConformerFilter!]
  any: [BindingSiteConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  score: F32Filter
  probability: F32Filter
  protein_conformer_id: UuidFilter
}

scalar BindingSiteConformerId

input BindingSiteConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_conformer_id: UuidSort
}

type BindingSiteInteraction {
  """Kind of interaction between the ligand and the receptor."""
  kind: BindingSiteInteractionKind!

  """In pi-stacking interactions what kind of stacking is happening?"""
  pi_stack_kind: PiStackKind

  """The ligand in the `Assembly` that is interacting with the receptor."""
  ligand: ResidueRef!

  """
  The atom in the ligand that is interacting with the receptor. Ignored
  for salt bridge and pi-interactions.
  """
  ligand_atom: AtomRef!

  """
  The co-ordinates of the interaction in the ligand. Often this is the
  co-ordinate of the `ligand_atom` but it is sometimes different (for
  example, in pi-stacking interactions).
  """
  ligand_xyz: Xyzf32!

  """The residue in the `Assembly` that is interacting with the ligand."""
  receptor_residue: ResidueRef!

  """
  The atom in the receptor that is interacting with the ligand. Ignored
  for salt bridge and pi-interactions.
  """
  receptor_atom: AtomRef!

  """
  The co-ordinates of the interaction in the receptor. Often this is the
  co-ordinate of the `receptor_atom` but it is sometimes different (for
  example, in pi-stacking interactions).
  """
  receptor_xyz: Xyzf32!

  """
  In hydrogen bonds and water bridges is the receptor the hydrogen bond
  donor?
  """
  receptor_is_donor: Boolean!

  """In pi-cation interactions is the receptor providing the charge?"""
  receptor_is_charged: Boolean!

  """In salt bridges is the receptor carrying the positive charge?"""
  receptor_is_positively_charged: Boolean!
}

input BindingSiteInteractionInput {
  """Kind of interaction between the ligand and the receptor."""
  kind: BindingSiteInteractionKind!

  """In pi-stacking interactions what kind of stacking is happening?"""
  pi_stack_kind: PiStackKind

  """The ligand in the `Assembly` that is interacting with the receptor."""
  ligand: ResidueRef!

  """
  The atom in the ligand that is interacting with the receptor. Ignored
  for salt bridge and pi-interactions.
  """
  ligand_atom: AtomRef!

  """
  The co-ordinates of the interaction in the ligand. Often this is the
  co-ordinate of the `ligand_atom` but it is sometimes different (for
  example, in pi-stacking interactions).
  """
  ligand_xyz: Xyzf32!

  """The residue in the `Assembly` that is interacting with the ligand."""
  receptor_residue: ResidueRef!

  """
  The atom in the receptor that is interacting with the ligand. Ignored
  for salt bridge and pi-interactions.
  """
  receptor_atom: AtomRef!

  """
  The co-ordinates of the interaction in the receptor. Often this is the
  co-ordinate of the `receptor_atom` but it is sometimes different (for
  example, in pi-stacking interactions).
  """
  receptor_xyz: Xyzf32!

  """
  In hydrogen bonds and water bridges is the receptor the hydrogen bond
  donor?
  """
  receptor_is_donor: Boolean!

  """In pi-cation interactions is the receptor providing the charge?"""
  receptor_is_charged: Boolean!

  """In salt bridges is the receptor carrying the positive charge?"""
  receptor_is_positively_charged: Boolean!
}

enum BindingSiteInteractionKind {
  UNKNOWN
  HYDROPHOBIC
  HYDROGEN_BOND
  HALOGEN_BOND
  WATER_BRIDGE
  SALT_BRIDGE
  PI_STACK
  PI_CATION
  METAL_COMPLEX
}

type BindingSiteInteractions implements Entity {
  id: BindingSiteInteractionsId!
  residues: [Int!]!
  interactions: [BindingSiteInteraction!]!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein: Protein!
  binding_pose_conformer_interactions(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerInteractionsFilter, sort: BindingPoseConformerInteractionsSort): BindingPoseConformerInteractionsConnection!
}

type BindingSiteInteractionsConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [BindingSiteInteractionsEdge!]!

  """A list of nodes."""
  nodes: [BindingSiteInteractions!]!
  total_count: Int!
}

"""An edge in a connection."""
type BindingSiteInteractionsEdge {
  """The item at the end of the edge"""
  node: BindingSiteInteractions!

  """A cursor for use in pagination"""
  cursor: String!
}

input BindingSiteInteractionsFilter {
  all: [BindingSiteInteractionsFilter!]
  any: [BindingSiteInteractionsFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
}

scalar BindingSiteInteractionsId

input BindingSiteInteractionsSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
}

enum BoolFilter {
  t
  f
}

type Chat implements Entity {
  id: ChatId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  messages(after: String, before: String, first: Int, last: Int, filter: MessageFilter, sort: MessageSort): MessageConnection!
}

type ChatConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ChatEdge!]!

  """A list of nodes."""
  nodes: [Chat!]!
  total_count: Int!
}

"""An edge in a connection."""
type ChatEdge {
  """The item at the end of the edge"""
  node: Chat!

  """A cursor for use in pagination"""
  cursor: String!
}

input ChatFilter {
  all: [ChatFilter!]
  any: [ChatFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar ChatId

input ChatSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

type Content {
  data: String!
  data_format: String!
}

input ContentInput {
  data: String!
  data_format: String!
}

input CreateBenchmark {
  name: String
  description: String
  tags: [String!]
  evaluation_script: String
  project_id: ProjectId!
}

input CreateBenchmarkData {
  name: String
  description: String
  tags: [String!]
  inputs: [BenchmarkArgInput!]!
  outputs: [BenchmarkArgInput!]!
  benchmark_id: BenchmarkId!
  project_id: ProjectId!
}

input CreateBenchmarkSubmission {
  name: String
  description: String
  tags: [String!]
  benchmark_id: BenchmarkId!
  project_id: ProjectId!
}

input CreateBindingAffinity {
  name: String
  description: String
  tags: [String!]
  affinity: Float!
  affinity_metric: String!
  protein_id: ProteinId!
  smol_id: SmolId!
  project_id: ProjectId!
}

input CreateBindingAffinityActivity {
  name: String
  description: String
  tags: [String!]
  sar_program_id: SarProgramId!
  binding_affinity_id: BindingAffinityId!
  project_id: ProjectId!
}

input CreateBindingPoseAffinity {
  name: String
  description: String
  tags: [String!]
  binding_affinity_id: BindingAffinityId!
  binding_pose_conformer_id: BindingPoseConformerId!
  project_id: ProjectId!
}

input CreateBindingPoseConformer {
  name: String
  description: String
  tags: [String!]
  smol_conformer_id: SmolConformerId!
  binding_site_conformer_id: BindingSiteConformerId!
  project_id: ProjectId!
}

input CreateBindingPoseConformerInteractions {
  name: String
  description: String
  tags: [String!]
  binding_pose_conformer_id: BindingPoseConformerId!
  binding_site_interactions_id: BindingSiteInteractionsId!
  project_id: ProjectId!
}

input CreateBindingSiteConformer {
  name: String
  description: String
  tags: [String!]
  bounding_box: BindingSiteBoundingBoxInput!
  surface_atoms: [Int!]
  score: Float
  probability: Float
  protein_conformer_id: ProteinConformerId!
  project_id: ProjectId!
}

input CreateBindingSiteInteractions {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  interactions: [BindingSiteInteractionInput!]!
  protein_id: ProteinId!
  project_id: ProjectId!
}

input CreateChat {
  name: String
  description: String
  tags: [String!]
  project_id: ProjectId!
}

input CreateMessage {
  name: String
  description: String
  tags: [String!]
  body: MessageBodyInput!
  user_prompt_id: UUID
  parent_id: UUID
  chat_id: ChatId!
  project_id: ProjectId!
}

input CreateMetadata {
  name: String
  description: String
  tags: [String!]
}

input CreateModule {
  path: String!
  tags: [String!]
  tests: [TestCase!]!
}

input CreateModuleInstance {
  path: String!
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget
  resources: ResourcesInput
  status: ModuleInstanceStatus
  metadata: CreateMetadata!
  out_tags: [[String!]]
  run_id: RunId
}

input CreateMultipleSequenceAlignment {
  name: String
  description: String
  tags: [String!]
  a_3m: TypedVirtualObject!
  protein_id: ProteinId!
  project_id: ProjectId!
}

input CreatePaper {
  name: String
  description: String
  tags: [String!]
  title: String!
  doi: String!
  h_index: Float
  impact_factor: Float
  authors: [String!]!
  paper_abstract: String!
  pdf: TypedVirtualObject
  keywords: [String!]!
  open_access: Boolean!
  project_id: ProjectId!
}

input CreatePaperContent {
  name: String
  description: String
  tags: [String!]
  content: PaperContentInput!
  paper_id: PaperId!
  project_id: ProjectId!
}

input CreateProject {
  name: String
  description: String
  tags: [String!]
}

input CreateProtein {
  name: String
  description: String
  tags: [String!]
  sequence: String!
  project_id: ProjectId!
}

input CreateProteinConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  protein_id: ProteinId!
  structure_id: StructureId!
  project_id: ProjectId!
}

input CreateResourceUtilization {
  module_instance_id: ModuleInstanceId!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

input CreateRun {
  name: String
  description: String
  tags: [String!]

  """Rex expression to run."""
  rex: String!

  """Optional mapping of modules to their full path versions."""
  module_lock: JSONObject
  project_id: ProjectId!
}

input CreateSarModel {
  name: String
  description: String
  tags: [String!]
  params: TypedVirtualObject!
  activity_type: ActivityType!
  sar_program_id: SarProgramId!
  project_id: ProjectId!
}

input CreateSarProgram {
  name: String
  description: String
  tags: [String!]
  project_id: ProjectId!
}

input CreateSmol {
  name: String
  description: String
  tags: [String!]
  smi: String
  inchi: String
  data_blocks: [[String!]!]
  project_id: ProjectId!
}

input CreateSmolConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  smol_id: SmolId!
  structure_id: StructureId!
  project_id: ProjectId!
}

input CreateSmolLibrary {
  name: String
  description: String
  tags: [String!]
  project_id: ProjectId!
}

input CreateSmolLibraryPartition {
  name: String
  description: String
  tags: [String!]
  part_idx: Int!
  part_size: Int!
  structures: TypedVirtualObject
  smiles: TypedVirtualObject!
  data_blocks: TypedVirtualObject!
  smol_library_id: SmolLibraryId!
  project_id: ProjectId!
}

input CreateStructure {
  name: String
  description: String
  tags: [String!]
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  project_id: ProjectId!
}

input CreateTag {
  name: String
  description: String
  tags: [String!]
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
  project_id: ProjectId!
}

type Credit {
  id: CreditId!
  amount: Int!
  module_instance_id: ModuleInstanceId
  resource_utilization_id: ResourceUtilizationId

  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
}

type CreditConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CreditEdge!]!

  """A list of nodes."""
  nodes: [Credit!]!
  total_count: Int!
}

"""An edge in a connection."""
type CreditEdge {
  """The item at the end of the edge"""
  node: Credit!

  """A cursor for use in pagination"""
  cursor: String!
}

input CreditFilter {
  all: [CreditFilter!]
  any: [CreditFilter!]
  id: UuidFilter
  account_id: UuidFilter
  amount: I64Filter
  stripe_event_id: StringFilter
  module_instance_id: UuidFilter
  resource_utilization_id: UuidFilter
  metadata: MetadataFilter
}

scalar CreditId

type CreditReport {
  pending: Int!
  finalized: Int!
}

input CreditSort {
  id: UuidSort
  account_id: UuidSort
  amount: I64Sort
  metadata: MetadataSort
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

input DateTimeFilter {
  is_null: Boolean
  eq: DateTime
  ne: DateTime
  gt: DateTime
  ge: DateTime
  lt: DateTime
  le: DateTime
}

enum DateTimeSort {
  asc
  desc
}

scalar Docs

type Done {
  ok: Boolean!
}

input DoneInput {
  ok: Boolean!
}

type DossierStatus {
  successes: [Protein!]!
  errors: [ErrorOutput!]!
}

type Download {
  content: [Content!]!
}

input DownloadInput {
  content: [ContentInput!]!
}

interface Entity {
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
}

type ErrorOutput {
  message: String!
}

input F32Filter {
  eq: Float
  ne: Float
  gt: Float
  ge: Float
  lt: Float
  le: Float
}

enum F32Sort {
  asc
  desc
}

input F64Filter {
  eq: Float
  ne: Float
  gt: Float
  ge: Float
  lt: Float
  le: Float
}

enum F64Sort {
  asc
  desc
}

type Figure {
  data: TypedVirtualObject!
}

input FigureInput {
  data: TypedVirtualObject!
}

input I32Filter {
  eq: Int
  ne: Int
  gt: Int
  ge: Int
  lt: Int
  le: Int
}

enum I32Sort {
  asc
  desc
}

input I64Filter {
  eq: Int
  ne: Int
  gt: Int
  ge: Int
  lt: Int
  le: Int
}

enum I64Sort {
  asc
  desc
}

"""A scalar that can represent any JSON value."""
scalar JSON

"""A scalar that can represent any JSON Object value."""
scalar JSONObject

type LogEntry {
  id: String!
  part: Int!

  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
  content: [String!]!
}

type LogEntryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LogEntryEdge!]!

  """A list of nodes."""
  nodes: [LogEntry!]!
  total_count: Int!
}

"""An edge in a connection."""
type LogEntryEdge {
  """The item at the end of the edge"""
  node: LogEntry!

  """A cursor for use in pagination"""
  cursor: String!
}

"""Units for memory and storage"""
enum MemUnits {
  B
  KB
  MB
  GB
  TB
}

type Message implements Entity {
  id: MessageId!
  body: MessageBody!
  user_prompt_id: UUID
  parent_id: UUID
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  chat: Chat!
}

union MessageBody = UserPrompt | WalterPrompt | UseTool | Thought | Answer | Done | Download

input MessageBodyInput {
  userPrompt: UserPromptInput
  walterPrompt: WalterPromptInput
  useTool: UseToolInput
  thought: ThoughtInput
  answer: AnswerInput
  done: DoneInput
  download: DownloadInput
}

type MessageConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessageEdge!]!

  """A list of nodes."""
  nodes: [Message!]!
  total_count: Int!
}

"""An edge in a connection."""
type MessageEdge {
  """The item at the end of the edge"""
  node: Message!

  """A cursor for use in pagination"""
  cursor: String!
}

input MessageFilter {
  all: [MessageFilter!]
  any: [MessageFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  user_prompt_id: UuidFilter
  parent_id: UuidFilter
  chat_id: UuidFilter
}

scalar MessageId

input MessageSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  user_prompt_id: UuidSort
  parent_id: UuidSort
  chat_id: UuidSort
}

type Metadata {
  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
}

input MetadataFilter {
  all: [MetadataFilter!]
  any: [MetadataFilter!]
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  name: StringFilter
  description: StringFilter
  run_id: UuidFilter
  tags: TagFilter
}

input MetadataSort {
  created_at: DateTimeSort
  updated_at: DateTimeSort
  deleted_at: DateTimeSort
  name: StringSort
  description: StringSort
}

"""
A module defines an interface to a program that can be run on a cluster.
It is a wrapper around a computational-chemistry program that defines well-typed inputs and outputs,
as well as resource requirements and documentation.
"""
type Module implements Entity {
  """Unique identifier for module"""
  id: ModuleId!

  """Path to module, used for resolving the module entrypoint"""
  path: String!

  """The types of the module's inputs"""
  ins: [Type!]!

  """The types of the module's outputs"""
  outs: [Type!]!

  """Docs for module inputs"""
  ins_docs: Docs

  """Docs for module outputs"""
  outs_docs: Docs

  """Usage instructions for module inputs"""
  ins_usage: [String!]

  """Usage instructions for module outputs"""
  outs_usage: [String!]

  """Targets that this module can be dispatched to"""
  targets: [ModuleInstanceTarget!]!

  """
  Resource specification indicating bounds on the resources required by this module
  """
  resource_bounds: ResourceBounds
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  run_id: RunId
  tags: [String!]
  source_run: Run
  typedesc: String!
}

type ModuleConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ModuleEdge!]!

  """A list of nodes."""
  nodes: [Module!]!
  total_count: Int!
}

"""An edge in a connection."""
type ModuleEdge {
  """The item at the end of the edge"""
  node: Module!

  """A cursor for use in pagination"""
  cursor: String!
}

type ModuleFailureContext {
  stderr: String
  stdout: String
  syserr: String
}

enum ModuleFailureReason {
  """Module arguments failed to resolve"""
  RESOLUTION

  """Module failed to dispatch to a cluster"""
  DISPATCH

  """Module failed during execution"""
  RUN

  """Module instance has not made any progress for a given timeout."""
  STALLED

  """Module instance can not be found on the cluster it was dispatched to."""
  MISSING

  """Module instance has been corrupted and does not have a valid status."""
  CORRUPTED

  """Module instance was does not have matching tracked credits."""
  CREDITS
}

input ModuleFailureReasonFilter {
  eq: ModuleFailureReason
  ne: ModuleFailureReason
}

input ModuleFilter {
  all: [ModuleFilter!]
  any: [ModuleFilter!]
  id: UuidFilter
  path: StringFilter
  metadata: MetadataFilter
}

scalar ModuleId

"""
A module instance is a single invocation of a module. It is created when a user submits a module
Can be thought of as a "job"
"""
type ModuleInstance implements Entity {
  """Unique identifier for module instance"""
  id: ModuleInstanceId!

  """Account that created the module instance"""
  account_id: AccountId!

  """Path to module, used for resolving the module entrypoint"""
  path: String!

  """When the module entered the QUEUED state"""
  queued_at: DateTime

  """When the module entered the ADMITTED state"""
  admitted_at: DateTime

  """When the module entered the DISPATCHED state"""
  dispatched_at: DateTime

  """When the module entered the RUNNING state"""
  run_at: DateTime

  """When the module entered the COMPLETED or FAILED state"""
  completed_at: DateTime

  """Module failure category"""
  failure_reason: ModuleFailureReason

  """Module failure context, useful for debugging"""
  failure_context: ModuleFailureContext

  """Current module instance status"""
  status: ModuleInstanceStatus!

  """Target that this module instance will be / is dispatched to"""
  target: ModuleInstanceTarget!

  """Resources allocated to this module instance"""
  resources: Resources

  """Progress of the module instance"""
  progress: ProgressEvent

  """Runtime account that the module instance is configured to use"""
  config_account: AccountId
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  module: Module!
  stdout(after: String, before: String, first: Int, last: Int, order: OrderBy): LogEntryConnection!
  stderr(after: String, before: String, first: Int, last: Int, order: OrderBy): LogEntryConnection!
  resource_utilization: ResourceUtilization
  ins: [Argument!]!
  outs: [Argument!]!
}

type ModuleInstanceConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ModuleInstanceEdge!]!

  """A list of nodes."""
  nodes: [ModuleInstance!]!
  total_count: Int!
}

"""An edge in a connection."""
type ModuleInstanceEdge {
  """The item at the end of the edge"""
  node: ModuleInstance!

  """A cursor for use in pagination"""
  cursor: String!
}

input ModuleInstanceFilter {
  all: [ModuleInstanceFilter!]
  any: [ModuleInstanceFilter!]
  id: UuidFilter
  account_id: UuidFilter
  path: StringFilter
  queued_at: DateTimeFilter
  admitted_at: DateTimeFilter
  dispatched_at: DateTimeFilter
  run_at: DateTimeFilter
  completed_at: DateTimeFilter
  failure_reason: ModuleFailureReasonFilter
  status: ModuleInstanceStatusFilter
  target: ModuleInstanceTargetFilter
  config_account: UuidFilter
  metadata: MetadataFilter
}

scalar ModuleInstanceId

input ModuleInstanceSort {
  id: UuidSort
  path: StringSort
  queued_at: DateTimeSort
  admitted_at: DateTimeSort
  dispatched_at: DateTimeSort
  run_at: DateTimeSort
  completed_at: DateTimeSort
  metadata: MetadataSort
}

enum ModuleInstanceStatus {
  """Module instance has been created."""
  CREATED

  """
  Module instance is waiting for its arguments to be resolved. It will be admitted once all of its
  dependencies have been resolved (meaning that the module instances that
  will produce these dependencies have completed).
  """
  RESOLVING

  """
  Module instance has been admitted. It will be dispatched when a cluster
  becomes available.
  """
  ADMITTED

  """
  Module instance has been dispatched to run on a cluster. This will run
  the module instance until it is done or until it yields.
  """
  DISPATCHED

  """
  Module instance is queued on the cluster. It will start running once the cluster's internal
  queue launches it.
  """
  QUEUED

  """Module instance is running and making progress on the cluster."""
  RUNNING

  """
  Module has finished calculation, but result upload still pending.
  We can dispatch more jobs, but cannot complete the module instance until the upload is complete.
  """
  AWAITING_UPLOAD

  """Module instance has been run to completion."""
  COMPLETED

  """Module instance failed to run."""
  FAILED

  """Module instance was cancelled."""
  CANCELLED
}

input ModuleInstanceStatusFilter {
  eq: ModuleInstanceStatus
  ne: ModuleInstanceStatus
}

enum ModuleInstanceTarget {
  TINY
  GADI
  BULLET
  BULLET_2
  BULLET_3
  BULLET_4
  SETONIX
  GADI_GPU
  BULLET_GPU
  BULLET_2_GPU
  BULLET_3_GPU
  BULLET_4_GPU
  SETONIX_GPU
  GADI_EXPRESS
  SETONIX_EXPRESS
}

input ModuleInstanceTargetFilter {
  eq: ModuleInstanceTarget
  ne: ModuleInstanceTarget
}

input ModuleSort {
  id: UuidSort
  path: StringSort
  metadata: MetadataSort
}

type MultipleSequenceAlignment implements Entity {
  id: MultipleSequenceAlignmentId!
  a_3m: TypedVirtualObject!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein: Protein!
}

type MultipleSequenceAlignmentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MultipleSequenceAlignmentEdge!]!

  """A list of nodes."""
  nodes: [MultipleSequenceAlignment!]!
  total_count: Int!
}

"""An edge in a connection."""
type MultipleSequenceAlignmentEdge {
  """The item at the end of the edge"""
  node: MultipleSequenceAlignment!

  """A cursor for use in pagination"""
  cursor: String!
}

input MultipleSequenceAlignmentFilter {
  all: [MultipleSequenceAlignmentFilter!]
  any: [MultipleSequenceAlignmentFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
}

scalar MultipleSequenceAlignmentId

input MultipleSequenceAlignmentSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
}

type Mutation {
  login(username: String!, password: String!): User
  redeem_voucher(voucher: String!): Int!
  destroy(module: ModuleId!): Module!
  delete_argument(arg_id: ArgumentId!): ArgumentId!
  delete_module_instance(module: ModuleInstanceId!): ModuleInstance!
  delete_token(token_id: TokenId!): Token!
  tag(module: ModuleId, module_instance: ModuleInstanceId, argument: ArgumentId, tags: [String!]!): [String!]!
  untag(module: ModuleId, module_instance: ModuleInstanceId, argument: ArgumentId, tags: [String!]!): [String!]!

  """DEPRECATED: use `run_module_instance` instead"""
  run(instance: CreateModuleInstance!): ModuleInstance!
  run_module_instance(instance: CreateModuleInstance!): ModuleInstance!

  """
  If a module instance fails due to environment issues (eg. inputs and module are valid),
  this method can be used to retry the module instance.
  """
  retry(instance: ModuleInstanceId!, target: ModuleInstanceTarget, resources: ResourcesInput): ModuleInstance!
  upload_large_object(typeinfo: JSON!, format: ObjectFormat!, public: Boolean): ObjectDescriptorWithUploadUrl!
  upload_object(file: Upload!, typeinfo: JSON!, format: ObjectFormat!): ObjectDescriptor!

  """Cancel a currently running instance, but don't delete it"""
  cancel(instance: ModuleInstanceId!): ModuleInstanceId!

  """
  An (admin) endpoint to update all attributes of a module instance.
  Only to be used in debug / rescue situations.
  """
  update_module_instance(instance_id: ModuleInstanceId!, instance_update: PatchModuleInstanceInput!, arguments_update: [ArgumentInput!]): ModuleInstance!

  """Track historical utilization"""
  track_module_instance_resource_utilization(utilization: CreateResourceUtilization!): ResourceUtilization!
  create_argument(name: String, typeinfo: JSON!, tags: [String!], value: JSON!): Argument!
  create_token: Token!
  deploy(module: CreateModule!): Module!

  """Cancel a run"""
  cancel_run(id: RunId!): Run!
  run_benchmark(input: CreateRun!, benchmark_id: BenchmarkId!, sample: Float): BenchmarkSubmission!
  eval(input: CreateRun!): Run!
  delete_run(run_id: RunId!): Run!
  update_account_config(account_id: AccountId!, input: AccountConfigInput!): AccountConfig!
  update_account_tier(account_id: AccountId!, tier: AccountTier!): AccountTier!
  fetch_protein_dossier(project_id: ProjectId!, uniprot_accession: String, pdb_ids: [String!]): DossierStatus!
  create_benchmark(input: CreateBenchmark!): Benchmark!
  delete_benchmark(benchmark_id: BenchmarkId!): Benchmark!
  patch_benchmark(benchmark_id: BenchmarkId!, input: PatchBenchmark!): Benchmark!
  create_benchmark_data(input: CreateBenchmarkData!): BenchmarkData!
  delete_benchmark_data(benchmark_data_id: BenchmarkDataId!): BenchmarkData!
  patch_benchmark_data(benchmark_data_id: BenchmarkDataId!, input: PatchBenchmarkData!): BenchmarkData!
  create_benchmark_submission(input: CreateBenchmarkSubmission!): BenchmarkSubmission!
  delete_benchmark_submission(benchmark_submission_id: BenchmarkSubmissionId!): BenchmarkSubmission!
  patch_benchmark_submission(benchmark_submission_id: BenchmarkSubmissionId!, input: PatchBenchmarkSubmission!): BenchmarkSubmission!
  create_binding_affinity(input: CreateBindingAffinity!): BindingAffinity!
  delete_binding_affinity(binding_affinity_id: BindingAffinityId!): BindingAffinity!
  patch_binding_affinity(binding_affinity_id: BindingAffinityId!, input: PatchBindingAffinity!): BindingAffinity!
  create_binding_site_conformer(input: CreateBindingSiteConformer!): BindingSiteConformer!
  delete_binding_site_conformer(binding_site_conformer_id: BindingSiteConformerId!): BindingSiteConformer!
  patch_binding_site_conformer(binding_site_conformer_id: BindingSiteConformerId!, input: PatchBindingSiteConformer!): BindingSiteConformer!
  create_binding_site_interactions(input: CreateBindingSiteInteractions!): BindingSiteInteractions!
  delete_binding_site_interactions(binding_site_interactions_id: BindingSiteInteractionsId!): BindingSiteInteractions!
  patch_binding_site_interactions(binding_site_interactions_id: BindingSiteInteractionsId!, input: PatchBindingSiteInteractions!): BindingSiteInteractions!
  create_binding_pose_affinity(input: CreateBindingPoseAffinity!): BindingPoseAffinity!
  delete_binding_pose_affinity(binding_pose_affinity_id: BindingPoseAffinityId!): BindingPoseAffinity!
  patch_binding_pose_affinity(binding_pose_affinity_id: BindingPoseAffinityId!, input: PatchBindingPoseAffinity!): BindingPoseAffinity!
  create_binding_pose_conformer(input: CreateBindingPoseConformer!): BindingPoseConformer!
  delete_binding_pose_conformer(binding_pose_conformer_id: BindingPoseConformerId!): BindingPoseConformer!
  patch_binding_pose_conformer(binding_pose_conformer_id: BindingPoseConformerId!, input: PatchBindingPoseConformer!): BindingPoseConformer!
  create_binding_pose_conformer_interactions(input: CreateBindingPoseConformerInteractions!): BindingPoseConformerInteractions!
  delete_binding_pose_conformer_interactions(binding_pose_conformer_interactions_id: BindingPoseConformerInteractionsId!): BindingPoseConformerInteractions!
  patch_binding_pose_conformer_interactions(binding_pose_conformer_interactions_id: BindingPoseConformerInteractionsId!, input: PatchBindingPoseConformerInteractions!): BindingPoseConformerInteractions!
  create_chat(input: CreateChat!): Chat!
  delete_chat(chat_id: ChatId!): Chat!
  patch_chat(chat_id: ChatId!, input: PatchChat!): Chat!
  create_message(input: CreateMessage!): Message!
  delete_message(message_id: MessageId!): Message!
  patch_message(message_id: MessageId!, input: PatchMessage!): Message!
  create_msa(input: CreateMultipleSequenceAlignment!): MultipleSequenceAlignment!
  delete_msa(multiple_sequence_alignment_id: MultipleSequenceAlignmentId!): MultipleSequenceAlignment!
  patch_msa(multiple_sequence_alignment_id: MultipleSequenceAlignmentId!, input: PatchMultipleSequenceAlignment!): MultipleSequenceAlignment!
  create_sar_program(input: CreateSarProgram!): SarProgram!
  delete_sar_program(sar_program_id: SarProgramId!): SarProgram!
  patch_sar_program(sar_program_id: SarProgramId!, input: PatchSarProgram!): SarProgram!
  create_sar_model(input: CreateSarModel!): SarModel!
  delete_sar_model(sar_model_id: SarModelId!): SarModel!
  patch_sar_model(sar_model_id: SarModelId!, input: PatchSarModel!): SarModel!
  create_binding_affinity_activity(input: CreateBindingAffinityActivity!): BindingAffinityActivity!
  delete_binding_affinity_activity(binding_affinity_activity_id: BindingAffinityActivityId!): BindingAffinityActivity!
  patch_binding_affinity_activity(binding_affinity_activity_id: BindingAffinityActivityId!, input: PatchBindingAffinityActivity!): BindingAffinityActivity!
  create_paper(input: CreatePaper!): Paper!
  delete_paper(paper_id: PaperId!): Paper!
  patch_paper(paper_id: PaperId!, input: PatchPaper!): Paper!
  create_paper_content(input: CreatePaperContent!): PaperContent!
  delete_paper_content(paper_content_id: PaperContentId!): PaperContent!
  patch_paper_content(paper_content_id: PaperContentId!, input: PatchPaperContent!): PaperContent!
  create_project(input: CreateProject!): Project!
  delete_project(project_id: ProjectId!): Project!
  patch_project(project_id: ProjectId!, input: PatchProject!): Project!
  create_protein(input: CreateProtein!): Protein!
  delete_protein(protein_id: ProteinId!): Protein!
  patch_protein(protein_id: ProteinId!, input: PatchProtein!): Protein!
  create_protein_conformer(input: CreateProteinConformer!): ProteinConformer!
  delete_protein_conformer(protein_conformer_id: ProteinConformerId!): ProteinConformer!
  patch_protein_conformer(protein_conformer_id: ProteinConformerId!, input: PatchProteinConformer!): ProteinConformer!
  create_smol_conformer(input: CreateSmolConformer!): SmolConformer!
  delete_smol_conformer(smol_conformer_id: SmolConformerId!): SmolConformer!
  patch_smol_conformer(smol_conformer_id: SmolConformerId!, input: PatchSmolConformer!): SmolConformer!
  create_smol_library(input: CreateSmolLibrary!): SmolLibrary!
  delete_smol_library(smol_library_id: SmolLibraryId!): SmolLibrary!
  patch_smol_library(smol_library_id: SmolLibraryId!, input: PatchSmolLibrary!): SmolLibrary!
  create_smol_library_partition(input: CreateSmolLibraryPartition!): SmolLibraryPartition!
  delete_smol_library_partition(smol_library_partition_id: SmolLibraryPartitionId!): SmolLibraryPartition!
  patch_smol_library_partition(smol_library_partition_id: SmolLibraryPartitionId!, input: PatchSmolLibraryPartition!): SmolLibraryPartition!
  create_smol(input: CreateSmol!): Smol!
  delete_smol(smol_id: SmolId!): Smol!
  patch_smol(smol_id: SmolId!, input: PatchSmol!): Smol!
  create_structure(input: CreateStructure!): Structure!
  delete_structure(structure_id: StructureId!): Structure!
  patch_structure(structure_id: StructureId!, input: PatchStructure!): Structure!
  create_tag(input: CreateTag!): Tag!
  delete_tag(tag_id: TagId!): Tag!
  patch_tag(tag_id: TagId!, input: PatchTag!): Tag!
}

type ObjectDescriptor {
  id: ObjectDescriptorId!

  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
  object: VirtualObject!
  type_info: Type!
  base_url: String!
  contents: JSON
  url: String
}

type ObjectDescriptorConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ObjectDescriptorEdge!]!

  """A list of nodes."""
  nodes: [ObjectDescriptor!]!
  total_count: Int!
}

"""An edge in a connection."""
type ObjectDescriptorEdge {
  """The item at the end of the edge"""
  node: ObjectDescriptor!

  """A cursor for use in pagination"""
  cursor: String!
}

input ObjectDescriptorFilter {
  all: [ObjectDescriptorFilter!]
  any: [ObjectDescriptorFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  object: VirtualObjectFilter
  base_url: StringFilter
  account_id: UuidFilter
}

scalar ObjectDescriptorId

input ObjectDescriptorSort {
  id: UuidSort
  metadata: MetadataSort
  object: VirtualObjectSort
  base_url: StringSort
}

type ObjectDescriptorWithUploadUrl {
  descriptor: ObjectDescriptor!
  upload_url: String!
}

enum ObjectFormat {
  json
  bin
}

input ObjectFormatFilter {
  eq: ObjectFormat
  ne: ObjectFormat
}

enum OrderBy {
  ASC
  DESC
}

"""Information about pagination in a connection"""
type PageInfo {
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Paper implements Entity {
  id: PaperId!
  title: String!
  doi: String!
  h_index: Float
  impact_factor: Float
  authors: [String!]!
  paper_abstract: String!
  pdf: TypedVirtualObject
  keywords: [String!]!
  open_access: Boolean!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  paper_contents(after: String, before: String, first: Int, last: Int, filter: PaperContentFilter, sort: PaperContentSort): PaperContentConnection!
}

type PaperConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PaperEdge!]!

  """A list of nodes."""
  nodes: [Paper!]!
  total_count: Int!
}

type PaperContent implements Entity {
  id: PaperContentId!
  content: PaperContentType!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  paper: Paper!
}

type PaperContentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PaperContentEdge!]!

  """A list of nodes."""
  nodes: [PaperContent!]!
  total_count: Int!
}

"""An edge in a connection."""
type PaperContentEdge {
  """The item at the end of the edge"""
  node: PaperContent!

  """A cursor for use in pagination"""
  cursor: String!
}

input PaperContentFilter {
  all: [PaperContentFilter!]
  any: [PaperContentFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  paper_id: UuidFilter
}

scalar PaperContentId

input PaperContentInput {
  figure: FigureInput
  table: TableInput
}

input PaperContentSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  paper_id: UuidSort
}

union PaperContentType = Figure | Table

"""An edge in a connection."""
type PaperEdge {
  """The item at the end of the edge"""
  node: Paper!

  """A cursor for use in pagination"""
  cursor: String!
}

input PaperFilter {
  all: [PaperFilter!]
  any: [PaperFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  title: StringFilter
  doi: StringFilter
  h_index: F32Filter
  impact_factor: F32Filter
  authors: TagFilter
  paper_abstract: StringFilter
  keywords: TagFilter
  open_access: BoolFilter
}

scalar PaperId

input PaperSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  title: StringSort
  doi: StringSort
  h_index: F32Sort
  impact_factor: F32Sort
  paper_abstract: StringSort
}

input PatchBenchmark {
  name: String
  description: String
  tags: [String!]
  evaluation_script: String
}

input PatchBenchmarkData {
  name: String
  description: String
  tags: [String!]
  inputs: [BenchmarkArgInput!]
  outputs: [BenchmarkArgInput!]
  benchmark_id: BenchmarkId
}

input PatchBenchmarkSubmission {
  name: String
  description: String
  tags: [String!]
  benchmark_id: BenchmarkId
}

input PatchBindingAffinity {
  name: String
  description: String
  tags: [String!]
  affinity: Float
  affinity_metric: String
  protein_id: ProteinId
  smol_id: SmolId
}

input PatchBindingAffinityActivity {
  name: String
  description: String
  tags: [String!]
  sar_program_id: SarProgramId
  binding_affinity_id: BindingAffinityId
}

input PatchBindingPoseAffinity {
  name: String
  description: String
  tags: [String!]
  binding_affinity_id: BindingAffinityId
  binding_pose_conformer_id: BindingPoseConformerId
}

input PatchBindingPoseConformer {
  name: String
  description: String
  tags: [String!]
  smol_conformer_id: SmolConformerId
  binding_site_conformer_id: BindingSiteConformerId
}

input PatchBindingPoseConformerInteractions {
  name: String
  description: String
  tags: [String!]
  binding_pose_conformer_id: BindingPoseConformerId
  binding_site_interactions_id: BindingSiteInteractionsId
}

input PatchBindingSiteConformer {
  name: String
  description: String
  tags: [String!]
  bounding_box: BindingSiteBoundingBoxInput
  surface_atoms: [Int!]
  score: Float
  probability: Float
  protein_conformer_id: ProteinConformerId
}

input PatchBindingSiteInteractions {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
  interactions: [BindingSiteInteractionInput!]
  protein_id: ProteinId
}

input PatchChat {
  name: String
  description: String
  tags: [String!]
}

input PatchMessage {
  name: String
  description: String
  tags: [String!]
  body: MessageBodyInput
  user_prompt_id: UUID
  parent_id: UUID
  chat_id: ChatId
}

input PatchModuleInstanceInput {
  path: String
  args: [ArgumentInput!]
  target: ModuleInstanceTarget
  resources: ResourcesInput
  status: ModuleInstanceStatus
  metadata: CreateMetadata
  out_tags: [[String!]]
  run_id: RunId
}

input PatchMultipleSequenceAlignment {
  name: String
  description: String
  tags: [String!]
  a_3m: TypedVirtualObject
  protein_id: ProteinId
}

input PatchPaper {
  name: String
  description: String
  tags: [String!]
  title: String
  doi: String
  h_index: Float
  impact_factor: Float
  authors: [String!]
  paper_abstract: String
  pdf: TypedVirtualObject
  keywords: [String!]
  open_access: Boolean
}

input PatchPaperContent {
  name: String
  description: String
  tags: [String!]
  content: PaperContentInput
  paper_id: PaperId
}

input PatchProject {
  name: String
  description: String
  tags: [String!]
}

input PatchProtein {
  name: String
  description: String
  tags: [String!]
  sequence: String
}

input PatchProteinConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
  protein_id: ProteinId
  structure_id: StructureId
}

input PatchSarModel {
  name: String
  description: String
  tags: [String!]
  params: TypedVirtualObject
  activity_type: ActivityType
  sar_program_id: SarProgramId
}

input PatchSarProgram {
  name: String
  description: String
  tags: [String!]
}

input PatchSmol {
  name: String
  description: String
  tags: [String!]
  smi: String
  inchi: String
  data_blocks: [[String!]!]
}

input PatchSmolConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
  smol_id: SmolId
  structure_id: StructureId
}

input PatchSmolLibrary {
  name: String
  description: String
  tags: [String!]
}

input PatchSmolLibraryPartition {
  name: String
  description: String
  tags: [String!]
  part_idx: Int
  part_size: Int
  structures: TypedVirtualObject
  smiles: TypedVirtualObject
  data_blocks: TypedVirtualObject
  smol_library_id: SmolLibraryId
}

input PatchStructure {
  name: String
  description: String
  tags: [String!]
  rcsb_id: String
  topology: TypedVirtualObject
  residues: TypedVirtualObject
  chains: TypedVirtualObject
}

input PatchTag {
  name: String
  description: String
  tags: [String!]
  key: String
  value: String
  tagged_id: UUID
  tagged_type: TaggedType
}

enum PiStackKind {
  UNKNOWN
  P
  T
}

type ProgressEvent {
  n: Int!
  n_expected: Int!
  n_max: Int!
  done: Boolean!
}

type Project implements Entity {
  id: ProjectId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  run_id: RunId
  tags: [String!]
  source_run: Run
  benchmark_submission(id: BenchmarkSubmissionId!): BenchmarkSubmission!
  binding_affinity(id: BindingAffinityId!): BindingAffinity!
  binding_affinity_activity(id: BindingAffinityActivityId!): BindingAffinityActivity!
  binding_pose_affinity(id: BindingPoseAffinityId!): BindingPoseAffinity!
  binding_pose_conformer(id: BindingPoseConformerId!): BindingPoseConformer!
  binding_pose_conformer_interaction(id: BindingPoseConformerInteractionsId!): BindingPoseConformerInteractions!
  binding_site_conformer(id: BindingSiteConformerId!): BindingSiteConformer!
  binding_site_interaction(id: BindingSiteInteractionsId!): BindingSiteInteractions!
  chat(id: ChatId!): Chat!
  msa(id: MultipleSequenceAlignmentId!): MultipleSequenceAlignment!
  paper(id: PaperId!): Paper!
  paper_content(id: PaperContentId!): PaperContent!
  protein(id: ProteinId!): Protein!
  protein_conformer(id: ProteinConformerId!): ProteinConformer!
  run(id: RunId!): Run!
  sar_model(id: SarModelId!): SarModel!
  sar_program(id: SarProgramId!): SarProgram!
  smol(id: SmolId!): Smol!
  smol_conformer(id: SmolConformerId!): SmolConformer!
  structure(id: StructureId!): Structure!
  benchmark_submissions(after: String, before: String, first: Int, last: Int, filter: BenchmarkSubmissionFilter, sort: BenchmarkSubmissionSort): BenchmarkSubmissionConnection!
  binding_affinities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityFilter, sort: BindingAffinitySort): BindingAffinityConnection!
  binding_affinity_activities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityActivityFilter, sort: BindingAffinityActivitySort): BindingAffinityActivityConnection!
  binding_pose_affinities(after: String, before: String, first: Int, last: Int, filter: BindingPoseAffinityFilter, sort: BindingPoseAffinitySort): BindingPoseAffinityConnection!
  binding_pose_conformers(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerFilter, sort: BindingPoseConformerSort): BindingPoseConformerConnection!
  binding_pose_conformer_interactions(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerInteractionsFilter, sort: BindingPoseConformerInteractionsSort): BindingPoseConformerInteractionsConnection!
  binding_site_conformers(after: String, before: String, first: Int, last: Int, filter: BindingSiteConformerFilter, sort: BindingSiteConformerSort): BindingSiteConformerConnection!
  binding_site_interactions(after: String, before: String, first: Int, last: Int, filter: BindingSiteInteractionsFilter, sort: BindingSiteInteractionsSort): BindingSiteInteractionsConnection!
  chats(after: String, before: String, first: Int, last: Int, filter: ChatFilter, sort: ChatSort): ChatConnection!
  msas(after: String, before: String, first: Int, last: Int, filter: MultipleSequenceAlignmentFilter, sort: MultipleSequenceAlignmentSort): MultipleSequenceAlignmentConnection!
  papers(after: String, before: String, first: Int, last: Int, filter: PaperFilter, sort: PaperSort): PaperConnection!
  paper_contents(after: String, before: String, first: Int, last: Int, filter: PaperContentFilter, sort: PaperContentSort): PaperContentConnection!
  proteins(after: String, before: String, first: Int, last: Int, filter: ProteinFilter, sort: ProteinSort): ProteinConnection!
  protein_conformers(after: String, before: String, first: Int, last: Int, filter: ProteinConformerFilter, sort: ProteinConformerSort): ProteinConformerConnection!
  runs(after: String, before: String, first: Int, last: Int, filter: RunFilter, sort: RunSort): RunConnection!
  sar_models(after: String, before: String, first: Int, last: Int, filter: SarModelFilter, sort: SarModelSort): SarModelConnection!
  sar_programs(after: String, before: String, first: Int, last: Int, filter: SarProgramFilter, sort: SarProgramSort): SarProgramConnection!
  smols(after: String, before: String, first: Int, last: Int, filter: SmolFilter, sort: SmolSort): SmolConnection!
  smol_conformers(after: String, before: String, first: Int, last: Int, filter: SmolConformerFilter, sort: SmolConformerSort): SmolConformerConnection!
  structures(after: String, before: String, first: Int, last: Int, filter: StructureFilter, sort: StructureSort): StructureConnection!
}

type ProjectConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProjectEdge!]!

  """A list of nodes."""
  nodes: [Project!]!
  total_count: Int!
}

"""An edge in a connection."""
type ProjectEdge {
  """The item at the end of the edge"""
  node: Project!

  """A cursor for use in pagination"""
  cursor: String!
}

input ProjectFilter {
  all: [ProjectFilter!]
  any: [ProjectFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  account_id: UuidFilter
}

scalar ProjectId

input ProjectSort {
  id: UuidSort
  metadata: MetadataSort
  account_id: UuidSort
}

type Protein implements Entity {
  id: ProteinId!
  sequence: String!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  msas(after: String, before: String, first: Int, last: Int, filter: MultipleSequenceAlignmentFilter, sort: MultipleSequenceAlignmentSort): MultipleSequenceAlignmentConnection!
  protein_conformers(after: String, before: String, first: Int, last: Int, filter: ProteinConformerFilter, sort: ProteinConformerSort): ProteinConformerConnection!
  binding_site_interactions(after: String, before: String, first: Int, last: Int, filter: BindingSiteInteractionsFilter, sort: BindingSiteInteractionsSort): BindingSiteInteractionsConnection!
  binding_affinities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityFilter, sort: BindingAffinitySort): BindingAffinityConnection!
}

type ProteinConformer implements Entity {
  id: ProteinConformerId!
  residues: [Int!]!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein: Protein!
  structure: Structure!
  binding_site_conformers(after: String, before: String, first: Int, last: Int, filter: BindingSiteConformerFilter, sort: BindingSiteConformerSort): BindingSiteConformerConnection!
}

type ProteinConformerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProteinConformerEdge!]!

  """A list of nodes."""
  nodes: [ProteinConformer!]!
  total_count: Int!
}

"""An edge in a connection."""
type ProteinConformerEdge {
  """The item at the end of the edge"""
  node: ProteinConformer!

  """A cursor for use in pagination"""
  cursor: String!
}

input ProteinConformerFilter {
  all: [ProteinConformerFilter!]
  any: [ProteinConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
  structure_id: UuidFilter
}

scalar ProteinConformerId

input ProteinConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
  structure_id: UuidSort
}

type ProteinConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [ProteinEdge!]!

  """A list of nodes."""
  nodes: [Protein!]!
  total_count: Int!
}

"""An edge in a connection."""
type ProteinEdge {
  """The item at the end of the edge"""
  node: Protein!

  """A cursor for use in pagination"""
  cursor: String!
}

input ProteinFilter {
  all: [ProteinFilter!]
  any: [ProteinFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  sequence: StringFilter
}

scalar ProteinId

input ProteinSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  sequence: StringSort
}

type Query {
  modules(after: String, before: String, first: Int, last: Int, sort: ModuleSort, filter: ModuleFilter): ModuleConnection!
  latest_modules(after: String, before: String, first: Int, last: Int, names: [String!], targets: [ModuleInstanceTarget!]): ModuleConnection!
  me: User!
  benchmark(id: BenchmarkId!): Benchmark!
  benchmarks(after: String, before: String, first: Int, last: Int, filter: BenchmarkFilter, sort: BenchmarkSort): BenchmarkConnection!
  smol_library(id: SmolLibraryId!): SmolLibrary!
  smol_libraries(after: String, before: String, first: Int, last: Int, sort: SmolLibrarySort): SmolLibraryConnection!
  module(id: ModuleId!): Module!
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  argument(id: ArgumentId!): Argument!
  object(id: ObjectDescriptorId!): ObjectDescriptor!
  object_path(path: UUID!): ObjectDescriptor!
}

scalar ResidueRef

"""Validation and hints to resources to use for an instance."""
type ResourceBounds {
  """number of gpus in node, None means no gpu required."""
  gpu_min: Int

  """max number of gpus in node that can used, 0 means no gpu support."""
  gpu_max: Int

  """optimal number of gpus in node"""
  gpu_hint: Int

  """minimum gpu memory required in MB per gpu"""
  gpu_mem_min: Int

  """maxmimum memory that can be used in MB (None means no limit)"""
  gpu_mem_max: Int

  """optimal gpu memory in MB"""
  gpu_mem_hint: Int

  """minimum number of cpus required, should be > 0 if Some"""
  cpu_min: Int

  """maximum number of cpus that can be used, 0 means no limit"""
  cpu_max: Int

  """optimal number of cpus"""
  cpu_hint: Int

  """minimum node count"""
  node_min: Int

  """maximum node count (e.g. maximum node parallelism)"""
  node_max: Int

  """most optimal node count"""
  node_hint: Int
  mem_min: Int
  mem_max: Int

  """in MB"""
  storage_min: Int

  """in MB (0 means no limit)"""
  storage_max: Int
}

"""Resources used by a module invocation"""
type ResourceUtilization {
  id: ResourceUtilizationId!
  module_instance_id: ModuleInstanceId!
  target: ModuleInstanceTarget!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
  account_id: AccountId!

  """When the entity was created"""
  created_at: DateTime!

  """Last time the entity was updated"""
  updated_at: DateTime!

  """
  When the entity was deleted, is used to determine if a module is soft-deleted
  """
  deleted_at: DateTime

  """User friendly name for the entity"""
  name: String

  """User friendly description for the entity"""
  description: String
  run_id: RunId

  """User defined tags for the entity"""
  tags: [String!]
}

scalar ResourceUtilizationId

type ResourceUtilizationReport {
  target: ModuleInstanceTarget!
  from: DateTime!
  to: DateTime!
  gpu_avg: Float
  mem_avg: Float
  storage_total: Float!
  storage_avg: Float!
  walltime_total: Float!
  walltime_avg: Float!
  cputime_total: Float!
  cputime_avg: Float!
  inodes_total: Float!
  sus_total: Int
}

"""
Explicit resources required for an instance.
Will fall back to the hint value if not specified.
"""
type Resources {
  gpus: Int
  cpus: Int
  nodes: Int

  """RAM allocation"""
  mem: Int

  """Defaults to MB"""
  mem_units: MemUnits
  gpu_mem: Int
  gpu_mem_units: MemUnits

  """
  space to be allocated on the target, must be > the size of Object inputs
  """
  storage: Int

  """Defaults to B"""
  storage_units: MemUnits

  """
  walltime request in minutes - job will be killed if it exceeds this number
  """
  walltime: Int

  """additional storage directories on target to mount"""
  storage_mounts: [String!]
}

"""
Explicit resources required for an instance.
Will fall back to the hint value if not specified.
"""
input ResourcesInput {
  gpus: Int
  cpus: Int
  nodes: Int

  """RAM allocation"""
  mem: Int

  """Defaults to MB"""
  mem_units: MemUnits
  gpu_mem: Int
  gpu_mem_units: MemUnits

  """
  space to be allocated on the target, must be > the size of Object inputs
  """
  storage: Int

  """Defaults to B"""
  storage_units: MemUnits

  """
  walltime request in minutes - job will be killed if it exceeds this number
  """
  walltime: Int

  """additional storage directories on target to mount"""
  storage_mounts: [String!]
}

type Run implements Entity {
  id: RunId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  run_id: RunId
  tags: [String!]
  rex: String!
  result: JSON
  trace: JSON
  module_lock: JSONObject!
  status: RunStatus!
  source_run: Run
  binding_affinities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityFilter, sort: BindingAffinitySort): BindingAffinityConnection!
  binding_affinity_activities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityActivityFilter, sort: BindingAffinityActivitySort): BindingAffinityActivityConnection!
  binding_pose_affinities(after: String, before: String, first: Int, last: Int, filter: BindingPoseAffinityFilter, sort: BindingPoseAffinitySort): BindingPoseAffinityConnection!
  binding_pose_conformers(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerFilter, sort: BindingPoseConformerSort): BindingPoseConformerConnection!
  binding_pose_conformer_interactions(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerInteractionsFilter, sort: BindingPoseConformerInteractionsSort): BindingPoseConformerInteractionsConnection!
  binding_site_interactions(after: String, before: String, first: Int, last: Int, filter: BindingSiteInteractionsFilter, sort: BindingSiteInteractionsSort): BindingSiteInteractionsConnection!
  binding_site_conformers(after: String, before: String, first: Int, last: Int, filter: BindingSiteConformerFilter, sort: BindingSiteConformerSort): BindingSiteConformerConnection!
  msas(after: String, before: String, first: Int, last: Int, filter: MultipleSequenceAlignmentFilter, sort: MultipleSequenceAlignmentSort): MultipleSequenceAlignmentConnection!
  proteins(after: String, before: String, first: Int, last: Int, filter: ProteinFilter, sort: ProteinSort): ProteinConnection!
  protein_conformers(after: String, before: String, first: Int, last: Int, filter: ProteinConformerFilter, sort: ProteinConformerSort): ProteinConformerConnection!
  sar_models(after: String, before: String, first: Int, last: Int, filter: SarModelFilter, sort: SarModelSort): SarModelConnection!
  smols(after: String, before: String, first: Int, last: Int, filter: SmolFilter, sort: SmolSort): SmolConnection!
  smol_conformers(after: String, before: String, first: Int, last: Int, filter: SmolConformerFilter, sort: SmolConformerSort): SmolConformerConnection!
  smol_libraries(after: String, before: String, first: Int, last: Int, filter: SmolLibraryFilter, sort: SmolLibrarySort): SmolLibraryConnection!
  structures(after: String, before: String, first: Int, last: Int, filter: StructureFilter, sort: StructureSort): StructureConnection!
  module_instances(after: String, before: String, first: Int, last: Int, filter: ModuleInstanceFilter, sort: ModuleInstanceSort): ModuleInstanceConnection!
}

type RunConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [RunEdge!]!

  """A list of nodes."""
  nodes: [Run!]!
  total_count: Int!
}

"""An edge in a connection."""
type RunEdge {
  """The item at the end of the edge"""
  node: Run!

  """A cursor for use in pagination"""
  cursor: String!
}

input RunFilter {
  all: [RunFilter!]
  any: [RunFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  rex: StringFilter
  status: RunStatusFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar RunId

input RunSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

enum RunStatus {
  PENDING
  RUNNING
  DONE
  ERROR
  CANCELLED
}

input RunStatusFilter {
  eq: RunStatus
  ne: RunStatus
}

type SarModel implements Entity {
  id: SarModelId!
  params: TypedVirtualObject!
  activity_type: ActivityType!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  sar_program: SarProgram!
}

type SarModelConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SarModelEdge!]!

  """A list of nodes."""
  nodes: [SarModel!]!
  total_count: Int!
}

"""An edge in a connection."""
type SarModelEdge {
  """The item at the end of the edge"""
  node: SarModel!

  """A cursor for use in pagination"""
  cursor: String!
}

input SarModelFilter {
  all: [SarModelFilter!]
  any: [SarModelFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  activity_type: ActivityTypeFilter
  sar_program_id: UuidFilter
}

scalar SarModelId

input SarModelSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  sar_program_id: UuidSort
}

type SarProgram implements Entity {
  id: SarProgramId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  sar_models(after: String, before: String, first: Int, last: Int, filter: SarModelFilter, sort: SarModelSort): SarModelConnection!
  binding_affinity_activities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityActivityFilter, sort: BindingAffinityActivitySort): BindingAffinityActivityConnection!
}

type SarProgramConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SarProgramEdge!]!

  """A list of nodes."""
  nodes: [SarProgram!]!
  total_count: Int!
}

"""An edge in a connection."""
type SarProgramEdge {
  """The item at the end of the edge"""
  node: SarProgram!

  """A cursor for use in pagination"""
  cursor: String!
}

input SarProgramFilter {
  all: [SarProgramFilter!]
  any: [SarProgramFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar SarProgramId

input SarProgramSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

type Smol implements Entity {
  id: SmolId!
  smi: String
  inchi: String
  data_blocks: [[String!]!]
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  smol_conformers(after: String, before: String, first: Int, last: Int, filter: SmolConformerFilter, sort: SmolConformerSort): SmolConformerConnection!
  binding_affinities(after: String, before: String, first: Int, last: Int, filter: BindingAffinityFilter, sort: BindingAffinitySort): BindingAffinityConnection!
}

type SmolConformer implements Entity {
  id: SmolConformerId!
  residues: [Int!]!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  smol: Smol!
  structure: Structure!
  binding_pose_conformers(after: String, before: String, first: Int, last: Int, filter: BindingPoseConformerFilter, sort: BindingPoseConformerSort): BindingPoseConformerConnection!
}

type SmolConformerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SmolConformerEdge!]!

  """A list of nodes."""
  nodes: [SmolConformer!]!
  total_count: Int!
}

"""An edge in a connection."""
type SmolConformerEdge {
  """The item at the end of the edge"""
  node: SmolConformer!

  """A cursor for use in pagination"""
  cursor: String!
}

input SmolConformerFilter {
  all: [SmolConformerFilter!]
  any: [SmolConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smol_id: UuidFilter
  structure_id: UuidFilter
}

scalar SmolConformerId

input SmolConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smol_id: UuidSort
  structure_id: UuidSort
}

type SmolConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SmolEdge!]!

  """A list of nodes."""
  nodes: [Smol!]!
  total_count: Int!
}

"""An edge in a connection."""
type SmolEdge {
  """The item at the end of the edge"""
  node: Smol!

  """A cursor for use in pagination"""
  cursor: String!
}

input SmolFilter {
  all: [SmolFilter!]
  any: [SmolFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smi: StringFilter
  inchi: StringFilter
}

scalar SmolId

type SmolLibrary implements Entity {
  id: SmolLibraryId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  partitions(after: String, before: String, first: Int, last: Int, filter: SmolLibraryPartitionFilter, sort: SmolLibraryPartitionSort): SmolLibraryPartitionConnection!
  size_hint: Int!
}

type SmolLibraryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SmolLibraryEdge!]!

  """A list of nodes."""
  nodes: [SmolLibrary!]!
  total_count: Int!
}

"""An edge in a connection."""
type SmolLibraryEdge {
  """The item at the end of the edge"""
  node: SmolLibrary!

  """A cursor for use in pagination"""
  cursor: String!
}

input SmolLibraryFilter {
  all: [SmolLibraryFilter!]
  any: [SmolLibraryFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar SmolLibraryId

type SmolLibraryPartition implements Entity {
  id: SmolLibraryPartitionId!
  part_idx: Int!
  part_size: Int!
  structures: TypedVirtualObject
  smiles: TypedVirtualObject!
  data_blocks: TypedVirtualObject!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  smol_library: SmolLibrary!
}

type SmolLibraryPartitionConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [SmolLibraryPartitionEdge!]!

  """A list of nodes."""
  nodes: [SmolLibraryPartition!]!
  total_count: Int!
}

"""An edge in a connection."""
type SmolLibraryPartitionEdge {
  """The item at the end of the edge"""
  node: SmolLibraryPartition!

  """A cursor for use in pagination"""
  cursor: String!
}

input SmolLibraryPartitionFilter {
  all: [SmolLibraryPartitionFilter!]
  any: [SmolLibraryPartitionFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  part_idx: I32Filter
  part_size: I32Filter
  smol_library_id: UuidFilter
}

scalar SmolLibraryPartitionId

input SmolLibraryPartitionSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  part_idx: I32Sort
  part_size: I32Sort
  smol_library_id: UuidSort
}

input SmolLibrarySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

input SmolSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smi: StringSort
  inchi: StringSort
}

input StringFilter {
  eq: String
  ne: String
  gt: String
  ge: String
  lt: String
  le: String
  like: String
  in: [String!]
}

enum StringSort {
  asc
  desc
}

type Structure implements Entity {
  id: StructureId!
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
  protein_conformers(after: String, before: String, first: Int, last: Int, filter: ProteinConformerFilter, sort: ProteinConformerSort): ProteinConformerConnection!
  smol_conformers(after: String, before: String, first: Int, last: Int, filter: SmolConformerFilter, sort: SmolConformerSort): SmolConformerConnection!
}

type StructureConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [StructureEdge!]!

  """A list of nodes."""
  nodes: [Structure!]!
  total_count: Int!
}

"""An edge in a connection."""
type StructureEdge {
  """The item at the end of the edge"""
  node: Structure!

  """A cursor for use in pagination"""
  cursor: String!
}

input StructureFilter {
  all: [StructureFilter!]
  any: [StructureFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  rcsb_id: StringFilter
}

scalar StructureId

input StructureSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  rcsb_id: StringSort
}

type Subscription {
  chat(id: ChatId!): Message!
  stream(argumentId: ArgumentId!): JSON!
}

type Table {
  data: JSONObject!
}

input TableInput {
  data: JSONObject!
}

type Tag implements Entity {
  id: TagId!
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
}

input TagFilter {
  in: [String!]
}

scalar TagId

enum TaggedType {
  structure
  protein
  protein_conformer
  smol
  smol_conformer
  run
  module
  module_instance
}

input TestCase {
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget!
  resources: ResourcesInput
  tags: [String!]
}

type Thought {
  content: [Content!]!
}

input ThoughtInput {
  content: [ContentInput!]!
}

type Token implements Entity {
  id: TokenId!
  name: String
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tags: [String!]
  source_run: Run
}

type TokenConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TokenEdge!]!

  """A list of nodes."""
  nodes: [Token!]!
  total_count: Int!
}

"""An edge in a connection."""
type TokenEdge {
  """The item at the end of the edge"""
  node: Token!

  """A cursor for use in pagination"""
  cursor: String!
}

input TokenFilter {
  all: [TokenFilter!]
  any: [TokenFilter!]
  metadata: MetadataFilter
  id: UuidFilter
  user_id: UuidFilter
}

scalar TokenId

input TokenSort {
  metadata: MetadataSort
  id: UuidSort
  user_id: UuidSort
}

scalar Type

scalar TypedVirtualObject

enum U64Sort {
  asc
  desc
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

scalar Upload

type UseTool {
  tool: String!
  args: JSON!
}

input UseToolInput {
  tool: String!
  args: JSON!
}

type User implements Entity {
  id: UserId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  run_id: RunId
  tags: [String!]
  source_run: Run
  account: Account!
  tokens(after: String, before: String, first: Int, last: Int, filter: TokenFilter, sort: TokenSort): TokenConnection!
}

scalar UserId

type UserPrompt {
  content: [Content!]!
}

input UserPromptInput {
  content: [ContentInput!]!
}

input UuidFilter {
  is_null: Boolean
  eq: UUID
  ne: UUID
  in: [UUID!]
}

enum UuidSort {
  asc
  desc
}

type V1Tag {
  tag: String!
  metadata: Metadata!
  count: Int!
}

type V1TagConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [V1TagEdge!]!

  """A list of nodes."""
  nodes: [V1Tag!]!
  total_count: Int!
}

"""An edge in a connection."""
type V1TagEdge {
  """The item at the end of the edge"""
  node: V1Tag!

  """A cursor for use in pagination"""
  cursor: String!
}

type VirtualObject {
  path: String!
  size: Int!
  format: ObjectFormat!
}

input VirtualObjectFilter {
  path: StringFilter
  size: I64Filter
  format: ObjectFormatFilter
}

input VirtualObjectSort {
  path: StringSort
  size: U64Sort
}

type WalterPrompt {
  content: [Content!]!
}

input WalterPromptInput {
  content: [ContentInput!]!
}

scalar Xyzf32

