type Account {
  id: AccountId!
  tier: AccountType!
  config: JSON
  created_at: DateTime!

  # Get a summary of resources utilization for the account
  resource_utilization(
    from: DateTime
    to: DateTime
  ): [ResourceUtilizationReport!]!
  module_instances(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    status: ModuleInstanceStatus
    target: ModuleInstanceTarget
    tags: [String!]
    ids: [ModuleInstanceId!]
    deleted: Boolean
    in_arguments: [ArgumentId!]
  ): SimpleModuleInstanceConnection!

  # Get all tags placed on module_instances
  module_instance_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
    min_count: Int
  ): TagConnection!
  arguments(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    typeinfo: [Type!]
    typequery: [TypeQuery!]
    tags: [String!]
    resolved: Boolean
    deleted: Boolean
  ): ArgumentConnection!

  # Get all tags placed on module_instances
  argument_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
  ): TagConnection!
  entities(
    after: String
    before: String
    first: Int
    last: Int
    filter: EntityFilterBy
    sort: EntitySortBy
  ): EntityConnection!
  experiments(
    after: String
    before: String
    first: Int
    last: Int
    filter: ExperimentFilterBy
    sort: ExperimentSortBy
  ): ExperimentConnection!
  projects(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProjectFilterBy
    sort: ProjectSortBy
  ): ProjectConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilterBy
    sort: ProteinSortBy
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilterBy
    sort: ProteinConformerSortBy
  ): ProteinConformerConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilterBy
    sort: SmolSortBy
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilterBy
    sort: SmolConformerSortBy
  ): SmolConformerConnection!
  smol_tautomers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolTautomerFilterBy
    sort: SmolTautomerSortBy
  ): SmolTautomerConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilterBy
    sort: StructureSortBy
  ): StructureConnection!
}

scalar AccountId

enum AccountType {
  FREE
  PRO
  STARTUP
  ACADEMIC
  ENTERPRISE
}

scalar Alt

type Argument {
  id: ArgumentId!
  name: String
  created_at: DateTime!
  deleted_at: DateTime
  rejected_at: DateTime
  resolved_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  tags: [String!]
  source: ModuleInstanceId
}

type ArgumentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ArgumentEdge!]!

  # A list of nodes.
  nodes: [Argument!]!
  totalCount: Int!
}

# An edge in a connection.
type ArgumentEdge {
  # The item at the end of the edge
  node: Argument!

  # A cursor for use in pagination
  cursor: String!
}

scalar ArgumentId

input ArgumentInput {
  id: ArgumentId
  name: String
  tags: [String!]
  value: JSON
}

scalar Bond

input CreateExperimentInput {
  name: String!
  data: ExperimentDataInput!
  project_id: UUID!
  smol_id: UUID!
  protein_id: UUID!
  tags: [String!]!
}

input CreateProjectInput {
  name: String!
  tags: [String!]!
}

input CreateProteinConformerInput {
  name: String
  project_id: UUID!
  protein_id: UUID!
  structure_id: UUID!
  tags: [String!]!
}

input CreateProteinInput {
  name: String!
  sequence: String!
  project_id: UUID!
  protein_id: UUID
  tags: [String!]!
}

input CreateSmolConformerInput {
  name: String
  smol_id: UUID!
  smol_tautomer_id: UUID!
  structure_id: UUID!
  project_id: UUID!
  tags: [String!]!
}

input CreateSmolInput {
  name: String!
  data: SmolDataInput!
  project_id: UUID!
  tags: [String!]!
}

input CreateSmolTautomerInput {
  name: String
  data: SmolTautomerDataInput!
  smol_id: UUID!
  project_id: UUID!
  tags: [String!]!
}

input CreateStructureInput {
  name: String!
  topology: TopologyInput!
  project_id: UUID!
  trajectory_id: UUID
  tags: [String!]!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  ne: DateTime
  gt: DateTime
  ge: DateTime
  lt: DateTime
  le: DateTime
}

enum Element {
  H
  HE
  LI
  BE
  B
  C
  N
  O
  F
  NE
  NA
  MG
  AL
  SI
  P
  S
  CL
  AR
  K
  CA
  SC
  TI
  V
  CR
  MN
  FE
  CO
  NI
  CU
  ZN
  GA
  GE
  AS
  SE
  BR
  KR
  RB
  SR
  Y
  ZR
  NB
  MO
  TC
  RU
  RH
  PD
  AG
  CD
  IN
  SN
  SB
  TE
  I
  XE
  CS
  BA
  LA
  CE
  PR
  ND
  PM
  SM
  EU
  GD
  TB
  DY
  HO
  ER
  TM
  YB
  LU
  HF
  TA
  W
  RE
  OS
  IR
  PT
  AU
  HG
  TL
  PB
  BI
  PO
  AT
  RN
  FR
  RA
  AC
  TH
  PA
  U
  NP
  PU
  AM
  CM
  BK
  CF
  ES
  FM
  MD
  NO
  LR
  RF
  DB
  SG
  BH
  HS
  MT
  DS
  RG
  CN
  NH
  FL
  MC
  LV
  TS
  OG
}

type Entity {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: JSON

  # User-defined tags.
  tags: [String!]!
}

type EntityConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [EntityEdge!]!

  # A list of nodes.
  nodes: [Entity!]!
  totalCount: Int!
}

# An edge in a connection.
type EntityEdge {
  # The item at the end of the edge
  node: Entity!

  # A cursor for use in pagination
  cursor: String!
}

input EntityFilterBy {
  and: [EntityFilterBy!]
  or: [EntityFilterBy!]
  not: EntityFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
}

scalar EntityId

input EntitySortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Experiment {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ExperimentData

  # User-defined tags.
  tags: [String!]!
}

type ExperimentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ExperimentEdge!]!

  # A list of nodes.
  nodes: [Experiment!]!
  totalCount: Int!
}

type ExperimentData {
  name: String!
  unit: String!
  measure: String!
  value: Float!
  assay: String!
}

input ExperimentDataInput {
  unit: String!
  measure: String!
  value: Float!
  assay: String!
}

# An edge in a connection.
type ExperimentEdge {
  # The item at the end of the edge
  node: Experiment!

  # A cursor for use in pagination
  cursor: String!
}

input ExperimentFilterBy {
  and: [ExperimentFilterBy!]
  or: [ExperimentFilterBy!]
  not: ExperimentFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ExperimentSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type GlobalStatus {
  created_at: DateTime!
  status: ModuleInstanceStatus!
  count: Int!
}

type GlobalStatusConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [GlobalStatusEdge!]!

  # A list of nodes.
  nodes: [GlobalStatus!]!
  totalCount: Int!
}

# An edge in a connection.
type GlobalStatusEdge {
  # The item at the end of the edge
  node: GlobalStatus!

  # A cursor for use in pagination
  cursor: String!
}

# A scalar that can represent any JSON value.
scalar JSON

type LogEntry {
  id: String!
  created_at: DateTime!
  content: [String!]!
}

type LogEntryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [LogEntryEdge!]!

  # A list of nodes.
  nodes: [LogEntry!]!
  totalCount: Int!
}

# An edge in a connection.
type LogEntryEdge {
  # The item at the end of the edge
  node: LogEntry!

  # A cursor for use in pagination
  cursor: String!
}

# Units for memory and storage
enum MemUnits {
  B
  KB
  MB
  GB
  TB
}

type Module {
  # Unique identifier for module
  id: ModuleId!
  created_at: DateTime!

  # When the module was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # Path to module, used for resolving the module entrypoint
  path: String!

  # Name of module, used for display + search purposes. Will strip _tengu / tengu_ from the path
  name: String!

  # The types of the module's inputs
  ins: [Type!]!

  # The types of the module's outputs
  outs: [Type!]!

  # Tags to apply to the module
  tags: [String!]

  # Description of module
  description: String

  # Usage instructions for module - NOTE: this is deprecated, use ins_usage and outs_usage instead
  usage: String

  # Usage instructions for module inputs
  ins_usage: [String!]

  # Usage instructions for module outputs
  outs_usage: [String!]

  # Targets that this module can be dispatched to
  targets: [ModuleInstanceTarget!]

  # Resource specification indicating bounds on the resources required by this module
  resource_bounds: ModuleResourceBounds
  typedesc: String!
}

type ModuleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModuleEdge!]!

  # A list of nodes.
  nodes: [Module!]!
  totalCount: Int!
}

# An edge in a connection.
type ModuleEdge {
  # The item at the end of the edge
  node: Module!

  # A cursor for use in pagination
  cursor: String!
}

type ModuleFailureContext {
  stderr: String
  stdout: String
  syserr: String
}

enum ModuleFailureReason {
  # Module arguments failed to resolve
  RESOLUTION

  # Module failed to dispatch to a cluster
  DISPATCH

  # Module failed during execution
  RUN

  # Module instance has not made any progress for a given timeout.
  STALLED

  # Module instance can not be found on the cluster it was dispatched to.
  MISSING

  # Module instance has been corrupted and does not have a valid status.
  CORRUPTED
}

scalar ModuleId

input ModuleInput {
  path: String!
  tags: [String!]
  tests: [TestCase!]!
}

type ModuleInstance {
  # Unique identifier for module instance
  id: ModuleInstanceId!

  # When the module instance was created
  created_at: DateTime!

  # When the module instance was deleted, is used to determine if a module instance is soft-deleted
  deleted_at: DateTime

  # Account that created the module instance
  account_id: AccountId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # The arguments that will be passed to the module instance
  ins: [Argument!]!

  # The arguments that will be produced by the module instance
  outs: [Argument!]!

  # Name of the module instance
  name: String

  # When the module entered the QUEUED state
  queued_at: DateTime

  # When the module entered the ADMITTED state
  admitted_at: DateTime

  # When the module entered the DISPATCHED state
  dispatched_at: DateTime

  # When the module entered the RUNNING state
  run_at: DateTime

  # When the module entered the COMPLETED or FAILED state
  completed_at: DateTime

  # Module failure category
  failure_reason: ModuleFailureReason

  # Module failure context, useful for debugging
  failure_context: ModuleFailureContext

  # Current module instance status
  status: ModuleInstanceStatus!

  # Target that this module instance will be / is dispatched to
  target: ModuleInstanceTarget!

  # Resources allocated to this module instance
  resources: ModuleInstanceResources

  # Progress of the module instance
  progress: ModuleInstanceProgress

  # Tags applied to the module instance
  tags: [String!]
  module: Module!
  stdout(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  stderr(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  resource_utilization: ResourceUtilization
}

scalar ModuleInstanceId

input ModuleInstanceInput {
  path: String!
  args: [ArgumentInput!]!
  name: String
  target: ModuleInstanceTarget

  # Resource specification
  resources: ModuleInstanceResourcesInput

  # Tags to place on the module instance
  tags: [String!]

  # Tags to apply to the outputs
  out_tags: [[String!]]

  # Tags to apply to the outputs
  out_names: [String]

  # Is this the final module intance in the pipeline?
  end: Boolean
}

type ModuleInstanceProgress {
  n: Int!
  n_expected: Int!
  n_max: Int!
  done: Boolean!
}

type ModuleInstanceResources {
  # Number of gpus to be allocated to job
  gpus: Int

  # Minimum amount of gpu memory required per gpu, denominate in gpu_mem_units
  gpu_mem: Int

  # Unit of gpu memory, defaults to B
  gpu_mem_units: MemUnits

  # Number of cpus to be allocated to job
  cpus: Int

  # Number of nodes to be allocated to job
  nodes: Int

  # Amount of RAM to be allocated to job, denominated in mem_units
  mem: Int

  # Units for RAM, defaults to B
  mem_units: MemUnits

  # Space to be allocated on the target denominated in storage_units, must be > the size of Object inputs.
  # The runtime will ensure this amount of space is reserved on the target, so try to take the output
  # size into account so that the target does not run out of space.
  storage: Int

  # Units for storage, defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int
  storage_mounts: [String!]
}

input ModuleInstanceResourcesInput {
  # Number of gpus to be allocated to job
  gpus: Int

  # Minimum amount of gpu memory required per gpu, denominate in gpu_mem_units
  gpu_mem: Int

  # Unit of gpu memory, defaults to B
  gpu_mem_units: MemUnits

  # Number of cpus to be allocated to job
  cpus: Int

  # Number of nodes to be allocated to job
  nodes: Int

  # Amount of RAM to be allocated to job, denominated in mem_units
  mem: Int

  # Units for RAM, defaults to B
  mem_units: MemUnits

  # Space to be allocated on the target denominated in storage_units, must be > the size of Object inputs.
  # The runtime will ensure this amount of space is reserved on the target, so try to take the output
  # size into account so that the target does not run out of space.
  storage: Int

  # Units for storage, defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int
  storage_mounts: [String!]
}

enum ModuleInstanceStatus {
  # Module instance has been created.
  CREATED

  # Module instance is waiting for its arguments to be resolved. It will be admitted once all of its
  # dependencies have been resolved (meaning that the module instances that
  # will produce these dependencies have completed).
  RESOLVING

  # Module instance has been admitted. It will be dispatched when a cluster
  # becomes available.
  ADMITTED

  # Module instance has been dispatched to run on a cluster. This will run
  # the module instance until it is done or until it yields.
  DISPATCHED

  # Module instance is queued on the cluster. It will start running once the cluster's internal
  # queue launches it.
  QUEUED

  # Module instance is running and making progress on the cluster.
  RUNNING

  # Module has finished calculation, but result upload still pending.
  # We can dispatch more jobs, but cannot complete the module instance until the upload is complete.
  AWAITING_UPLOAD

  # Module instance has been run to completion.
  COMPLETED

  # Module instance failed to run.
  FAILED

  # Module instance was cancelled.
  CANCELLED
}

enum ModuleInstanceTarget {
  NIX
  GADI
  NIX_SSH
  NIX_SSH_2
  NIX_SSH_3
  NIX_SSH_4
  SETONIX
  GADI_GPU
  NIX_SSH_GPU
  NIX_SSH_2_GPU
  NIX_SSH_3_GPU
  NIX_SSH_4_GPU
  SETONIX_GPU
  GADI_EXPRESS
  SETONIX_EXPRESS
}

type ModuleResourceBounds {
  # number of gpus in node, 0 means no gpu required.
  gpu_min: Int!

  # max number of gpus in node that can used, 0 means no gpu support.
  gpu_max: Int!

  # optimal number of gpus in node
  gpu_hint: Int!

  # minimum gpu memory required in MB per gpu
  gpu_mem_min: Int

  # maxmimum memory that can be used in MB (None means no limit)
  gpu_mem_max: Int

  # optimal gpu memory in MB
  gpu_mem_hint: Int

  # minimum number of cpus required, should be > 0 if Some
  cpu_min: Int

  # maximum number of cpus that can be used, 0 means no limit
  cpu_max: Int

  # optimal number of cpus
  cpu_hint: Int

  # minimum node count
  node_min: Int!

  # maximum node count (e.g. maximum node parallelism)
  node_max: Int!

  # most optimal node count
  node_hint: Int!

  # Min RAM in MB
  mem_min: Int!

  # Max RAM in MB (0 means no limit)
  mem_max: Int!

  # in MB
  storage_min: Int!

  # in MB (0 means no limit)
  storage_max: Int!
}

type Mutation {
  login(username: String!, password: String!): User
  deploy(module: ModuleInput!): SimpleModule!
  destroy(module: ModuleId!): SimpleModule!
  delete_argument(arg_id: ArgumentId!): Argument!
  delete_module_instance(module: ModuleInstanceId!): SimpleModuleInstance!
  delete_token(token_id: TokenId!): Token!
  rename(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    name: String
  ): [String!]!
  tag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  untag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  upload_arg(
    typeinfo: JSON!
    tags: [String!]
    file: Upload!
    name: String
  ): Argument!

  # Cancel a currently running instance, but don't delete it
  cancel(instance: ModuleInstanceId!): ModuleInstanceId!

  # If a module instance fails due to environment issues (eg. inputs and module are valid),
  # this method can be used to retry the module instance.
  retry(
    instance: ModuleInstanceId!
    target: ModuleInstanceTarget
    resources: ModuleInstanceResourcesInput
  ): SimpleModuleInstance!
  run(instance: ModuleInstanceInput!): SimpleModuleInstance!

  # An (admin) endpoint to update all attributes of a module instance.
  # Only to be used in debug / rescue situations.
  update_module_instance(
    instance_update: UpdateModuleInstanceInput!
  ): SimpleModuleInstance!

  # Track historical utilization
  track_module_instance_resource_utilization(
    utilization: ResourceUtilizationInput!
  ): ResourceUtilization!
  create_argument(
    name: String
    typeinfo: JSON!
    tags: [String!]
    value: JSON!
  ): Argument!
  create_token: Token!
  create_entity(entity: RawEntityInput!): Entity!
  create_experiment(input: CreateExperimentInput!): Experiment!
  create_project(input: CreateProjectInput!): Project!
  create_protein(input: CreateProteinInput!): Protein!
  create_protein_conformer(
    input: CreateProteinConformerInput!
  ): ProteinConformer!
  create_smol(input: CreateSmolInput!): Smol!
  create_smol_conformer(input: CreateSmolConformerInput!): SmolConformer!
  create_smol_tautomer(input: CreateSmolTautomerInput!): SmolTautomer!
  create_structure(input: CreateStructureInput!): Structure!
}

type Object {
  id: ArgumentId!
  name: String
  created_at: DateTime!
  deleted_at: DateTime
  rejected_at: DateTime
  resolved_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  tags: [String!]
  source: ModuleInstanceId
  contents: JSON!
  url: String!
}

enum Order {
  ASC
  DESC
}

enum OrderBy {
  ASC
  DESC
}

# Information about pagination in a connection
type PageInfo {
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Project {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProjectData

  # User-defined tags.
  tags: [String!]!
  experiments(
    after: String
    before: String
    first: Int
    last: Int
    filter: ExperimentFilterBy
    sort: ExperimentSortBy
  ): ExperimentConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilterBy
    sort: ProteinSortBy
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilterBy
    sort: ProteinConformerSortBy
  ): ProteinConformerConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilterBy
    sort: SmolSortBy
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilterBy
    sort: SmolConformerSortBy
  ): SmolConformerConnection!
  smol_tautomers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolTautomerFilterBy
    sort: SmolTautomerSortBy
  ): SmolTautomerConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilterBy
    sort: StructureSortBy
  ): StructureConnection!
}

type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProjectEdge!]!

  # A list of nodes.
  nodes: [Project!]!
  totalCount: Int!
}

type ProjectData {
  name: String!
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge
  node: Project!

  # A cursor for use in pagination
  cursor: String!
}

input ProjectFilterBy {
  and: [ProjectFilterBy!]
  or: [ProjectFilterBy!]
  not: ProjectFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
}

input ProjectSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Protein {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProteinData

  # User-defined tags.
  tags: [String!]!
}

type ProteinConformer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProteinConformerData

  # User-defined tags.
  tags: [String!]!
}

type ProteinConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinConformerEdge!]!

  # A list of nodes.
  nodes: [ProteinConformer!]!
  totalCount: Int!
}

type ProteinConformerData {
  name: String
}

# An edge in a connection.
type ProteinConformerEdge {
  # The item at the end of the edge
  node: ProteinConformer!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinConformerFilterBy {
  and: [ProteinConformerFilterBy!]
  or: [ProteinConformerFilterBy!]
  not: ProteinConformerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ProteinConformerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type ProteinConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinEdge!]!

  # A list of nodes.
  nodes: [Protein!]!
  totalCount: Int!
}

type ProteinData {
  sequence: String!
  name: String!
}

# An edge in a connection.
type ProteinEdge {
  # The item at the end of the edge
  node: Protein!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinFilterBy {
  and: [ProteinFilterBy!]
  or: [ProteinFilterBy!]
  not: ProteinFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ProteinSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Query {
  modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    deleted: Boolean
    tags: [String!]
  ): ModuleConnection!
  latest_modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    names: [String!]
    targets: [ModuleInstanceTarget!]
  ): ModuleConnection!
  me: User!
  status_by_name(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameConnection!
  status_by_name_and_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameAndAccountConnection!
  status_by_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByAccountConnection!
  global_status(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): GlobalStatusConnection!
  utilization_for_target(
    target: ModuleInstanceTarget!
    from: DateTime
    to: DateTime
  ): ResourceUtilizationReport!
  module(id: ModuleId!): Module!
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  argument(id: ArgumentId!): Argument!
  object(id: ArgumentId!): Object
  entity(id: UUID!): Entity
  experiment(id: UUID!): Experiment
  project(id: UUID!): Project
  protein(id: UUID!): Protein
  protein_conformer(id: UUID!): ProteinConformer
  smol(id: UUID!): Smol
  smol_conformer(id: UUID!): SmolConformer
  smol_tautomer(id: UUID!): SmolTautomer
  structure(id: UUID!): Structure
}

input RawEntityInput {
  # System-defined data that is directly accessible to users.
  data: JSON

  # User-defined tags.
  tags: [String!]!
}

type ResourceUtilization {
  id: ResourceUtilizationId!
  created_at: DateTime!
  module_instance_id: ModuleInstanceId!
  target: ModuleInstanceTarget!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

scalar ResourceUtilizationId

input ResourceUtilizationInput {
  moduleInstanceId: ModuleInstanceId!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

type ResourceUtilizationReport {
  target: ModuleInstanceTarget!
  from: DateTime!
  to: DateTime!
  gpu_avg: Float
  mem_avg: Float
  storage_total: Float!
  storage_avg: Float!
  walltime_total: Float!
  walltime_avg: Float!
  cputime_total: Float!
  cputime_avg: Float!
  inodes_total: Float!
  sus_total: Int
}

# A module defines an interface to a program that can be run on a cluster.
# It is a wrapper around a computational-chemistry program that defines well-typed inputs and outputs,
# as well as resource requirements and documentation.
type SimpleModule {
  # Unique identifier for module
  id: ModuleId!

  # When the module was created
  created_at: DateTime!

  # When the module was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # Path to module, used for resolving the module entrypoint
  path: String!

  # Name of module, used for display + search purposes. Will strip _tengu / tengu_ from the path
  name: String!

  # The types of the module's inputs
  ins: [Type!]!

  # The types of the module's outputs
  outs: [Type!]!

  # Tags to apply to the module
  tags: [String!]

  # Description of module
  description: String

  # Usage instructions for module - NOTE: this is deprecated, use ins_usage and outs_usage instead
  usage: String

  # Usage instructions for module inputs
  ins_usage: [String!]

  # Usage instructions for module outputs
  outs_usage: [String!]

  # Targets that this module can be dispatched to
  targets: [ModuleInstanceTarget!]

  # Resource specification indicating bounds on the resources required by this module
  resource_bounds: ModuleResourceBounds
}

# A module instance is a single invocation of a module. It is created when a user submits a module
# Can be thought of as a "job"
type SimpleModuleInstance {
  # Unique identifier for module instance
  id: ModuleInstanceId!

  # When the module instance was created
  created_at: DateTime!

  # When the module instance was deleted, is used to determine if a module instance is soft-deleted
  deleted_at: DateTime

  # Account that created the module instance
  account_id: AccountId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # The arguments that will be passed to the module instance
  ins: [Argument!]!

  # The arguments that will be produced by the module instance
  outs: [Argument!]!

  # Name of the module instance
  name: String

  # When the module entered the QUEUED state
  queued_at: DateTime

  # When the module entered the ADMITTED state
  admitted_at: DateTime

  # When the module entered the DISPATCHED state
  dispatched_at: DateTime

  # When the module entered the RUNNING state
  run_at: DateTime

  # When the module entered the COMPLETED or FAILED state
  completed_at: DateTime

  # Module failure category
  failure_reason: ModuleFailureReason

  # Module failure context, useful for debugging
  failure_context: ModuleFailureContext

  # Current module instance status
  status: ModuleInstanceStatus!

  # Target that this module instance will be / is dispatched to
  target: ModuleInstanceTarget!

  # Resources allocated to this module instance
  resources: ModuleInstanceResources

  # Progress of the module instance
  progress: ModuleInstanceProgress

  # Tags applied to the module instance
  tags: [String!]
}

type SimpleModuleInstanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SimpleModuleInstanceEdge!]!

  # A list of nodes.
  nodes: [SimpleModuleInstance!]!
  totalCount: Int!
}

# An edge in a connection.
type SimpleModuleInstanceEdge {
  # The item at the end of the edge
  node: SimpleModuleInstance!

  # A cursor for use in pagination
  cursor: String!
}

type Smol {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolData

  # User-defined tags.
  tags: [String!]!
}

type SmolConformer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolConformerData

  # User-defined tags.
  tags: [String!]!
}

type SmolConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolConformerEdge!]!

  # A list of nodes.
  nodes: [SmolConformer!]!
  totalCount: Int!
}

type SmolConformerData {
  name: String
}

# An edge in a connection.
type SmolConformerEdge {
  # The item at the end of the edge
  node: SmolConformer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolConformerFilterBy {
  and: [SmolConformerFilterBy!]
  or: [SmolConformerFilterBy!]
  not: SmolConformerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input SmolConformerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type SmolConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolEdge!]!

  # A list of nodes.
  nodes: [Smol!]!
  totalCount: Int!
}

type SmolData {
  name: String!
  smi: String
  inchi: String!
}

input SmolDataInput {
  smi: String
  inchi: String!
}

# An edge in a connection.
type SmolEdge {
  # The item at the end of the edge
  node: Smol!

  # A cursor for use in pagination
  cursor: String!
}

input SmolFilterBy {
  and: [SmolFilterBy!]
  or: [SmolFilterBy!]
  not: SmolFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
  smol_name: StringFilter
}

input SmolSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type SmolTautomer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolTautomerData

  # User-defined tags.
  tags: [String!]!
}

type SmolTautomerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolTautomerEdge!]!

  # A list of nodes.
  nodes: [SmolTautomer!]!
  totalCount: Int!
}

type SmolTautomerData {
  inchi: String!
  name: String
}

input SmolTautomerDataInput {
  inchi: String!
}

# An edge in a connection.
type SmolTautomerEdge {
  # The item at the end of the edge
  node: SmolTautomer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolTautomerFilterBy {
  and: [SmolTautomerFilterBy!]
  or: [SmolTautomerFilterBy!]
  not: SmolTautomerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input SmolTautomerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type StatusByAccount {
  created_at: DateTime!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByAccountEdge {
  # The item at the end of the edge
  node: StatusByAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByName {
  created_at: DateTime!
  name: String!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccount {
  created_at: DateTime!
  name: String!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameAndAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByNameAndAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameAndAccountEdge {
  # The item at the end of the edge
  node: StatusByNameAndAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByNameConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameEdge!]!

  # A list of nodes.
  nodes: [StatusByName!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameEdge {
  # The item at the end of the edge
  node: StatusByName!

  # A cursor for use in pagination
  cursor: String!
}

input StringFilter {
  eq: String
  ne: String
  gt: String
  ge: String
  lt: String
  le: String
  like: String
  in: [String!]
  not_in: [String!]
}

type Structure {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: StructureData

  # User-defined tags.
  tags: [String!]!
  topology: Topology!
  signed_url: String!
}

type StructureConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StructureEdge!]!

  # A list of nodes.
  nodes: [Structure!]!
  totalCount: Int!
}

type StructureData {
  name: String!
  topology: TopologyObject!
}

# An edge in a connection.
type StructureEdge {
  # The item at the end of the edge
  node: Structure!

  # A cursor for use in pagination
  cursor: String!
}

input StructureFilterBy {
  and: [StructureFilterBy!]
  or: [StructureFilterBy!]
  not: StructureFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input StructureSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Subscription {
  stream(argumentId: ArgumentId!): JSON!
}

type Tag {
  tag: String!
  created_at: DateTime!
  count: Int!
}

type TagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TagEdge!]!

  # A list of nodes.
  nodes: [Tag!]!
  totalCount: Int!
}

# An edge in a connection.
type TagEdge {
  # The item at the end of the edge
  node: Tag!

  # A cursor for use in pagination
  cursor: String!
}

input TagFilter {
  all: [String!]
  any: [String!]
}

input TestCase {
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget!
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

type Token {
  id: TokenId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type TokenConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TokenEdge!]!

  # A list of nodes.
  nodes: [Token!]!
  totalCount: Int!
}

# An edge in a connection.
type TokenEdge {
  # The item at the end of the edge
  node: Token!

  # A cursor for use in pagination
  cursor: String!
}

input TokenFilterBy {
  and: [TokenFilterBy!]
  or: [TokenFilterBy!]
  not: TokenFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
}

scalar TokenId

input TokenSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

# An structure-of-arrays based representation of coordinates, charges and bonds between atoms, with utilty functions to manipulate them.
# # Example
# ```
# use qdx_common::{Bond, Topology, TopologyVersion};
# use qdx_common::element::Element;
# Topology {
# version: Some(TopologyVersion::V1),
# symbols: vec![Element::H, Element::O, Element::H],
# geometry: vec![0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# connectivity: Some(vec![Bond(0,1,1), Bond(1,2,1)]),
# formal_charges: Some(vec![0,0,0]),
# fragments: Some(vec![vec![0,1,2]]),
# fragment_formal_charges: Some(vec![0]),
# fragment_partial_charges: Some(vec![0.0]),
# fragment_multiplicities: Some(vec![1]),
# ..Default::default()
# };
# /* JSON
# {
# "symbols": ["H", "O", "H"],
# "geometry": [0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# "connectivity": [[0,1,1], [1,2,1]],
# "charges": [0,0,0],
# "fragments": [[0,1,2]],
# "fragment_formal_charges": [0]
# "fragment_partial_charges": [0]
# "fragment_multiplicities": [1]
# }
# */
# ```
type Topology {
  version: TopologyVersion

  # Atomic symbols of elements
  symbols: [Element!]!

  # Flat vector of X,Y,Z coordinates for atoms in Angstroms
  geometry: [Float!]!

  # Contains the x, y, z components of initial atom velocities in Angstroms/ps
  # V1 only
  velocities: [Float!]

  # Bonds between atoms
  connectivity: [Bond!]

  # Formal charges for each atom
  # V0 version was atom_charges
  formal_charges: [Int!]

  # DEPRECATED please upgrade to V1 and use formal_charges instead
  # Formal charges for each atom
  atom_charges: [Int!]

  # Contains the Mulliken partial charges for each of the atoms
  partial_charges: [Float!]

  # Mapping of atoms to their label
  # V0 version was atom_labels
  labels: [String!]

  # DEPRECATED please upgrade to V1 and use labels instead
  # Mapping of atoms to their label
  atom_labels: [String!]

  # A list of fragments, where each fragment is a list of atom indices
  fragments: [[Int!]!]

  # A list of sums of all atom formal charges for each fragment
  # V0 version was fragment_charges
  fragment_formal_charges: [Int!]

  # DEPRECATED please upgrade to V1 and use fragment_formal_charges instead
  # A list of sums of all atom formal charges for each fragment
  fragment_charges: [Int!]

  # A list of sums of all atom partial charges for each fragment
  fragment_partial_charges: [Float!]

  # A list of multiplicities for each fragment. Fragment multiplicity is a measure
  # of the energy level of a fragment, and is related to the number of unpaired electrons within the fragment
  fragment_multiplicities: [Int!]
  alts: [Alt!]
}

# An structure-of-arrays based representation of coordinates, charges and bonds between atoms, with utilty functions to manipulate them.
# # Example
# ```
# use qdx_common::{Bond, Topology, TopologyVersion};
# use qdx_common::element::Element;
# Topology {
# version: Some(TopologyVersion::V1),
# symbols: vec![Element::H, Element::O, Element::H],
# geometry: vec![0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# connectivity: Some(vec![Bond(0,1,1), Bond(1,2,1)]),
# formal_charges: Some(vec![0,0,0]),
# fragments: Some(vec![vec![0,1,2]]),
# fragment_formal_charges: Some(vec![0]),
# fragment_partial_charges: Some(vec![0.0]),
# fragment_multiplicities: Some(vec![1]),
# ..Default::default()
# };
# /* JSON
# {
# "symbols": ["H", "O", "H"],
# "geometry": [0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# "connectivity": [[0,1,1], [1,2,1]],
# "charges": [0,0,0],
# "fragments": [[0,1,2]],
# "fragment_formal_charges": [0]
# "fragment_partial_charges": [0]
# "fragment_multiplicities": [1]
# }
# */
# ```
input TopologyInput {
  version: TopologyVersion

  # Atomic symbols of elements
  symbols: [Element!]!

  # Flat vector of X,Y,Z coordinates for atoms in Angstroms
  geometry: [Float!]!

  # Contains the x, y, z components of initial atom velocities in Angstroms/ps
  # V1 only
  velocities: [Float!]

  # Bonds between atoms
  connectivity: [Bond!]

  # Formal charges for each atom
  # V0 version was atom_charges
  formal_charges: [Int!]

  # DEPRECATED please upgrade to V1 and use formal_charges instead
  # Formal charges for each atom
  atom_charges: [Int!]

  # Contains the Mulliken partial charges for each of the atoms
  partial_charges: [Float!]

  # Mapping of atoms to their label
  # V0 version was atom_labels
  labels: [String!]

  # DEPRECATED please upgrade to V1 and use labels instead
  # Mapping of atoms to their label
  atom_labels: [String!]

  # A list of fragments, where each fragment is a list of atom indices
  fragments: [[Int!]!]

  # A list of sums of all atom formal charges for each fragment
  # V0 version was fragment_charges
  fragment_formal_charges: [Int!]

  # DEPRECATED please upgrade to V1 and use fragment_formal_charges instead
  # A list of sums of all atom formal charges for each fragment
  fragment_charges: [Int!]

  # A list of sums of all atom partial charges for each fragment
  fragment_partial_charges: [Float!]

  # A list of multiplicities for each fragment. Fragment multiplicity is a measure
  # of the energy level of a fragment, and is related to the number of unpaired electrons within the fragment
  fragment_multiplicities: [Int!]
  alts: [Alt!]
}

scalar TopologyObject

enum TopologyVersion {
  # Version prior to hermes v3
  V0

  # Hermes v3
  V1
}

scalar Type

input TypeQuery {
  path: [String!]!
  query: JSON!
}

# A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
# Strings within GraphQL. UUIDs are used to assign unique identifiers to
# entities without requiring a central allocating authority.
#
# # References
#
# * [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
# * [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
scalar UUID

input UpdateModuleInstanceInput {
  id: ModuleInstanceId!
  path: String
  ins: [ArgumentInput!]
  outs: [ArgumentInput!]
  target: ModuleInstanceTarget
  status: ModuleInstanceStatus
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

scalar Upload

type User {
  id: UserId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  account_id: AccountId!
  account: Account
  token(
    after: String
    before: String
    first: Int
    last: Int
    filter: TokenFilterBy
    sort: TokenSortBy
  ): TokenConnection!
}

scalar UserId

input UuidFilter {
  eq: UUID
  ne: UUID
  in: [UUID!]
}
