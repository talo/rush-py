type Account {
  id: AccountId!
  created_at: DateTime!

  # Get a summary of resources utilization for the account
  resource_utilization(
    from: DateTime
    to: DateTime
  ): [ResourceUtilizationReport!]!
  module_instances(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    status: ModuleInstanceStatus
    target: ModuleInstanceTarget
    tags: [String!]
    ids: [ModuleInstanceId!]
    deleted: Boolean
  ): SimpleModuleInstanceConnection!

  # Get all tags placed on module_instances
  module_instance_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
    min_count: Int
  ): TagConnection!
  arguments(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    typeinfo: Type
    tags: [String!]
    deleted: Boolean
  ): ArgumentConnection!

  # Get all tags placed on module_instances
  argument_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
  ): TagConnection!
  entities(
    after: String
    before: String
    first: Int
    last: Int
    filter: EntityFilterBy
    sort: EntitySortBy
  ): EntityConnection!
  experiments(
    after: String
    before: String
    first: Int
    last: Int
    filter: ExperimentFilterBy
    sort: ExperimentSortBy
  ): ExperimentConnection!
  projects(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProjectFilterBy
    sort: ProjectSortBy
  ): ProjectConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilterBy
    sort: ProteinSortBy
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilterBy
    sort: ProteinConformerSortBy
  ): ProteinConformerConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilterBy
    sort: SmolSortBy
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilterBy
    sort: SmolConformerSortBy
  ): SmolConformerConnection!
  smol_tautomers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolTautomerFilterBy
    sort: SmolTautomerSortBy
  ): SmolTautomerConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilterBy
    sort: StructureSortBy
  ): StructureConnection!
}

scalar AccountId

scalar Alt

type Argument {
  id: ArgumentId!
  created_at: DateTime!
  deleted_at: DateTime
  rejected_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  tags: [String!]
  source: ModuleInstanceId
}

type ArgumentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ArgumentEdge!]!

  # A list of nodes.
  nodes: [Argument!]!
  totalCount: Int!
}

# An edge in a connection.
type ArgumentEdge {
  # The item at the end of the edge
  node: Argument!

  # A cursor for use in pagination
  cursor: String!
}

scalar ArgumentId

input ArgumentInput {
  id: ArgumentId
  value: JSON
  tags: [String!]
}

scalar Bond

input CreateExperimentInput {
  name: String!
  data: ExperimentDataInput!
  project_id: UUID!
  smol_id: UUID!
  protein_id: UUID!
  tags: [String!]!
}

input CreateProjectInput {
  name: String!
  tags: [String!]!
}

input CreateProteinConformerInput {
  name: String
  project_id: UUID!
  protein_id: UUID!
  structure_id: UUID!
  tags: [String!]!
}

input CreateProteinInput {
  name: String!
  sequence: String!
  project_id: UUID!
  protein_id: UUID
  tags: [String!]!
}

input CreateSmolConformerInput {
  name: String
  smol_id: UUID!
  smol_tautomer_id: UUID!
  structure_id: UUID!
  project_id: UUID!
  tags: [String!]!
}

input CreateSmolInput {
  name: String!
  data: SmolDataInput!
  project_id: UUID!
  tags: [String!]!
}

input CreateSmolTautomerInput {
  name: String
  data: SmolTautomerDataInput!
  smol_id: UUID!
  project_id: UUID!
  tags: [String!]!
}

input CreateStructureInput {
  name: String!
  topology: TopologyInput!
  project_id: UUID!
  trajectory_id: UUID
  tags: [String!]!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  ne: DateTime
  gt: DateTime
  ge: DateTime
  lt: DateTime
  le: DateTime
}

type Entity {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: JSON

  # User-defined tags.
  tags: [String!]!
}

type EntityConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [EntityEdge!]!

  # A list of nodes.
  nodes: [Entity!]!
  totalCount: Int!
}

# An edge in a connection.
type EntityEdge {
  # The item at the end of the edge
  node: Entity!

  # A cursor for use in pagination
  cursor: String!
}

input EntityFilterBy {
  and: [EntityFilterBy!]
  or: [EntityFilterBy!]
  not: EntityFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
}

scalar EntityId

input EntitySortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Experiment {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ExperimentData

  # User-defined tags.
  tags: [String!]!
}

type ExperimentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ExperimentEdge!]!

  # A list of nodes.
  nodes: [Experiment!]!
  totalCount: Int!
}

type ExperimentData {
  name: String!
  unit: String!
  measure: String!
  value: Float!
  assay: String!
}

input ExperimentDataInput {
  unit: String!
  measure: String!
  value: Float!
  assay: String!
}

# An edge in a connection.
type ExperimentEdge {
  # The item at the end of the edge
  node: Experiment!

  # A cursor for use in pagination
  cursor: String!
}

input ExperimentFilterBy {
  and: [ExperimentFilterBy!]
  or: [ExperimentFilterBy!]
  not: ExperimentFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ExperimentSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type GlobalStatus {
  created_at: DateTime!
  status: ModuleInstanceStatus!
  count: Int!
}

type GlobalStatusConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [GlobalStatusEdge!]!

  # A list of nodes.
  nodes: [GlobalStatus!]!
  totalCount: Int!
}

# An edge in a connection.
type GlobalStatusEdge {
  # The item at the end of the edge
  node: GlobalStatus!

  # A cursor for use in pagination
  cursor: String!
}

# A scalar that can represent any JSON value.
scalar JSON

type LogEntry {
  id: String!
  created_at: DateTime!
  content: [String!]!
}

type LogEntryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [LogEntryEdge!]!

  # A list of nodes.
  nodes: [LogEntry!]!
  totalCount: Int!
}

# An edge in a connection.
type LogEntryEdge {
  # The item at the end of the edge
  node: LogEntry!

  # A cursor for use in pagination
  cursor: String!
}

# Units for memory and storage
enum MemUnits {
  B
  KB
  MB
  GB
  TB
}

type Module {
  id: ModuleId!
  created_at: DateTime!
  deleted_at: DateTime
  path: String!
  ins: [Type!]!
  outs: [Type!]!
  tags: [String!]
  description: String
  usage: String
  ins_usage: [String!]
  outs_usage: [String!]
  targets: [ModuleInstanceTarget!]
  resource_bounds: ModuleResourceBounds
  typedesc: String!
}

type ModuleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModuleEdge!]!

  # A list of nodes.
  nodes: [Module!]!
  totalCount: Int!
}

# An edge in a connection.
type ModuleEdge {
  # The item at the end of the edge
  node: Module!

  # A cursor for use in pagination
  cursor: String!
}

enum ModuleFailureReason {
  # Module arguments failed to resolve
  RESOLUTION

  # Module failed to dispatch to a cluster
  DISPATCH

  # Module failed during execution
  RUN

  # Module instance has not made any progress for a given timeout.
  STALLED

  # Module instance can not be found on the cluster it was dispatched to.
  MISSING

  # Module instance has been corrupted and does not have a valid status.
  CORRUPTED
}

scalar ModuleId

input ModuleInput {
  path: String!
  tags: [String!]
  tests: [TestCase!]!
}

type ModuleInstance {
  id: ModuleInstanceId!
  created_at: DateTime!
  deleted_at: DateTime
  account_id: AccountId!
  path: String!
  ins: [Argument!]!
  outs: [Argument!]!
  queued_at: DateTime
  admitted_at: DateTime
  dispatched_at: DateTime
  run_at: DateTime
  completed_at: DateTime
  failure_reason: ModuleFailureReason
  status: ModuleInstanceStatus!
  target: ModuleInstanceTarget!
  resources: ModuleInstanceResources
  progress: ModuleInstanceProgress
  tags: [String!]
  module: Module!
  stdout(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  stderr(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  resource_utilization: ResourceUtilization
}

scalar ModuleInstanceId

input ModuleInstanceInput {
  path: String!
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget

  # Resource specification
  resources: ModuleInstanceResourcesInput

  # Tags to place on the module instance
  tags: [String!]

  # Tags to apply to the outputs
  out_tags: [[String!]]

  # Is this the final module intance in the pipeline?
  end: Boolean
}

type ModuleInstanceProgress {
  n: Int!
  n_expected: Int!
  n_max: Int!
  done: Boolean!
}

type ModuleInstanceResources {
  gpus: Int
  gpu_mem: Int
  gpu_mem_units: MemUnits
  cpus: Int
  nodes: Int
  mem: Int
  mem_units: MemUnits
  storage: Int
  storage_units: MemUnits
  walltime: Int
  storage_mounts: [String!]
}

input ModuleInstanceResourcesInput {
  gpus: Int
  gpu_mem: Int
  gpu_mem_units: MemUnits
  cpus: Int
  nodes: Int
  mem: Int
  mem_units: MemUnits
  storage: Int
  storage_units: MemUnits
  walltime: Int
  storage_mounts: [String!]
}

enum ModuleInstanceStatus {
  # Module instance has been created.
  CREATED

  # Module instance is waiting for its arguments to be resolved. It will be admitted once all of its
  # dependencies have been resolved (meaning that the module instances that
  # will produce these dependencies have completed).
  RESOLVING

  # Module instance has been admitted. It will be dispatched when a cluster
  # becomes available.
  ADMITTED

  # Module instance has been dispatched to run on a cluster. This will run
  # the module instance until it is done or until it yields.
  DISPATCHED

  # Module instance is queued on the cluster. It will start running once the cluster's internal
  # queue launches it.
  QUEUED

  # Module instance is running and making progress on the cluster.
  RUNNING

  # Module has finished calculation, but result upload still pending.
  # We can dispatch more jobs, but cannot complete the module instance until the upload is complete.
  AWAITING_UPLOAD

  # Module instance has been run to completion.
  COMPLETED

  # Module instance failed to run.
  FAILED

  # Module instance was cancelled.
  CANCELLED
}

enum ModuleInstanceTarget {
  NIX
  GADI
  NIX_SSH
  NIX_SSH_2
  NIX_SSH_3
  NIX_SSH_4
  SETONIX
  GADI_GPU
  NIX_SSH_GPU
  NIX_SSH_2_GPU
  NIX_SSH_3_GPU
  NIX_SSH_4_GPU
  SETONIX_GPU
  GADI_EXPRESS
  SETONIX_EXPRESS
}

type ModuleResourceBounds {
  # number of gpus in node, 0 means no gpu required.
  gpu_min: Int!

  # max number of gpus in node that can used, 0 means no gpu support.
  gpu_max: Int!

  # optimal number of gpus in node
  gpu_hint: Int!

  # minimum gpu memory required in MB per gpu
  gpu_mem_min: Int

  # maxmimum memory that can be used in MB (None means no limit)
  gpu_mem_max: Int

  # optimal gpu memory in MB
  gpu_mem_hint: Int

  # minimum number of cpus required, should be > 0 if Some
  cpu_min: Int

  # maximum number of cpus that can be used, 0 means no limit
  cpu_max: Int

  # optimal number of cpus
  cpu_hint: Int

  # minimum node count
  node_min: Int!

  # maximum node count (e.g. maximum node parallelism)
  node_max: Int!

  # most optimal node count
  node_hint: Int!

  # Min RAM in MB
  mem_min: Int!

  # Max RAM in MB (0 means no limit)
  mem_max: Int!

  # in MB
  storage_min: Int!

  # in MB (0 means no limit)
  storage_max: Int!
}

type Mutation {
  login(username: String!, password: String!): User!
  deploy(module: ModuleInput!): SimpleModule!
  destroy(module: ModuleId!): SimpleModule!
  delete_module_instance(module: ModuleInstanceId!): SimpleModuleInstance!
  tag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  untag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  upload_arg(typeinfo: JSON!, tags: [String!], file: Upload!): Argument!

  # Cancel a currently running instance, but don't delete it
  cancel(instance: ModuleInstanceId!): ModuleInstanceId!

  # If a module instance fails due to environment issues (eg. inputs and module are valid),
  # this method can be used to retry the module instance.
  retry(
    instance: ModuleInstanceId!
    target: ModuleInstanceTarget
    resources: ModuleInstanceResourcesInput
  ): SimpleModuleInstance!
  run(instance: ModuleInstanceInput!): SimpleModuleInstance!

  # An (admin) endpoint to update all attributes of a module instance.
  # Only to be used in debug / rescue situations.
  update_module_instance(
    instance_update: UpdateModuleInstanceInput!
  ): SimpleModuleInstance!

  # Track historical utilization
  track_module_instance_resource_utilization(
    utilization: ResourceUtilizationInput!
  ): ResourceUtilization!
  create_entity(entity: RawEntityInput!): Entity!
  create_experiment(input: CreateExperimentInput!): Experiment!
  create_project(input: CreateProjectInput!): Project!
  create_protein(input: CreateProteinInput!): Protein!
  create_protein_conformer(
    input: CreateProteinConformerInput!
  ): ProteinConformer!
  create_smol(input: CreateSmolInput!): Smol!
  create_smol_conformer(input: CreateSmolConformerInput!): SmolConformer!
  create_smol_tautomer(input: CreateSmolTautomerInput!): SmolTautomer!
  create_structure(input: CreateStructureInput!): Structure!
}

enum Order {
  ASC
  DESC
}

enum OrderBy {
  ASC
  DESC
}

# Information about pagination in a connection
type PageInfo {
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Project {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProjectData

  # User-defined tags.
  tags: [String!]!
  experiments(
    after: String
    before: String
    first: Int
    last: Int
    filter: ExperimentFilterBy
    sort: ExperimentSortBy
  ): ExperimentConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilterBy
    sort: ProteinSortBy
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilterBy
    sort: ProteinConformerSortBy
  ): ProteinConformerConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilterBy
    sort: SmolSortBy
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilterBy
    sort: SmolConformerSortBy
  ): SmolConformerConnection!
  smol_tautomers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolTautomerFilterBy
    sort: SmolTautomerSortBy
  ): SmolTautomerConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilterBy
    sort: StructureSortBy
  ): StructureConnection!
}

type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProjectEdge!]!

  # A list of nodes.
  nodes: [Project!]!
  totalCount: Int!
}

type ProjectData {
  name: String!
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge
  node: Project!

  # A cursor for use in pagination
  cursor: String!
}

input ProjectFilterBy {
  and: [ProjectFilterBy!]
  or: [ProjectFilterBy!]
  not: ProjectFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
}

input ProjectSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Protein {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProteinData

  # User-defined tags.
  tags: [String!]!
}

type ProteinConformer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: ProteinConformerData

  # User-defined tags.
  tags: [String!]!
}

type ProteinConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinConformerEdge!]!

  # A list of nodes.
  nodes: [ProteinConformer!]!
  totalCount: Int!
}

type ProteinConformerData {
  name: String
}

# An edge in a connection.
type ProteinConformerEdge {
  # The item at the end of the edge
  node: ProteinConformer!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinConformerFilterBy {
  and: [ProteinConformerFilterBy!]
  or: [ProteinConformerFilterBy!]
  not: ProteinConformerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ProteinConformerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type ProteinConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinEdge!]!

  # A list of nodes.
  nodes: [Protein!]!
  totalCount: Int!
}

type ProteinData {
  sequence: String!
  name: String!
}

# An edge in a connection.
type ProteinEdge {
  # The item at the end of the edge
  node: Protein!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinFilterBy {
  and: [ProteinFilterBy!]
  or: [ProteinFilterBy!]
  not: ProteinFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input ProteinSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Query {
  modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    deleted: Boolean
    tags: [String!]
  ): ModuleConnection!
  latest_modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    names: [String!]
    targets: [ModuleInstanceTarget!]
  ): ModuleConnection!
  me: User!
  status_by_name(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameConnection!
  status_by_name_and_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameAndAccountConnection!
  status_by_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByAccountConnection!
  global_status(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): GlobalStatusConnection!
  utilization_for_target(
    target: ModuleInstanceTarget!
    from: DateTime
    to: DateTime
  ): ResourceUtilizationReport!
  module(id: ModuleId!): Module!
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  argument(id: ArgumentId!): Argument!
  object(id: ArgumentId!): JSON!
  entity(id: UUID!): Entity
  experiment(id: UUID!): Experiment
  project(id: UUID!): Project
  protein(id: UUID!): Protein
  protein_conformer(id: UUID!): ProteinConformer
  smol(id: UUID!): Smol
  smol_conformer(id: UUID!): SmolConformer
  smol_tautomer(id: UUID!): SmolTautomer
  structure(id: UUID!): Structure
}

input RawEntityInput {
  # System-defined data that is directly accessible to users.
  data: JSON

  # User-defined tags.
  tags: [String!]!
}

type ResourceUtilization {
  id: ResourceUtilizationId!
  created_at: DateTime!
  module_instance_id: ModuleInstanceId!
  target: ModuleInstanceTarget!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

scalar ResourceUtilizationId

input ResourceUtilizationInput {
  moduleInstanceId: ModuleInstanceId!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

type ResourceUtilizationReport {
  target: ModuleInstanceTarget!
  from: DateTime!
  to: DateTime!
  gpu_avg: Float
  mem_avg: Float
  storage_total: Float!
  storage_avg: Float!
  walltime_total: Float!
  walltime_avg: Float!
  cputime_total: Float!
  cputime_avg: Float!
  inodes_total: Float!
  sus_total: Int
}

type SimpleModule {
  id: ModuleId!
  created_at: DateTime!
  deleted_at: DateTime
  path: String!
  ins: [Type!]!
  outs: [Type!]!
  tags: [String!]
  description: String
  usage: String
  ins_usage: [String!]
  outs_usage: [String!]
  targets: [ModuleInstanceTarget!]
  resource_bounds: ModuleResourceBounds
}

type SimpleModuleInstance {
  id: ModuleInstanceId!
  created_at: DateTime!
  deleted_at: DateTime
  account_id: AccountId!
  path: String!
  ins: [Argument!]!
  outs: [Argument!]!
  queued_at: DateTime
  admitted_at: DateTime
  dispatched_at: DateTime
  run_at: DateTime
  completed_at: DateTime
  failure_reason: ModuleFailureReason
  status: ModuleInstanceStatus!
  target: ModuleInstanceTarget!
  resources: ModuleInstanceResources
  progress: ModuleInstanceProgress
  tags: [String!]
}

type SimpleModuleInstanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SimpleModuleInstanceEdge!]!

  # A list of nodes.
  nodes: [SimpleModuleInstance!]!
  totalCount: Int!
}

# An edge in a connection.
type SimpleModuleInstanceEdge {
  # The item at the end of the edge
  node: SimpleModuleInstance!

  # A cursor for use in pagination
  cursor: String!
}

type Smol {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolData

  # User-defined tags.
  tags: [String!]!
}

type SmolConformer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolConformerData

  # User-defined tags.
  tags: [String!]!
}

type SmolConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolConformerEdge!]!

  # A list of nodes.
  nodes: [SmolConformer!]!
  totalCount: Int!
}

type SmolConformerData {
  name: String
}

# An edge in a connection.
type SmolConformerEdge {
  # The item at the end of the edge
  node: SmolConformer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolConformerFilterBy {
  and: [SmolConformerFilterBy!]
  or: [SmolConformerFilterBy!]
  not: SmolConformerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input SmolConformerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type SmolConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolEdge!]!

  # A list of nodes.
  nodes: [Smol!]!
  totalCount: Int!
}

type SmolData {
  name: String!
  smi: String
  inchi: String!
}

input SmolDataInput {
  smi: String
  inchi: String!
}

# An edge in a connection.
type SmolEdge {
  # The item at the end of the edge
  node: Smol!

  # A cursor for use in pagination
  cursor: String!
}

input SmolFilterBy {
  and: [SmolFilterBy!]
  or: [SmolFilterBy!]
  not: SmolFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input SmolSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type SmolTautomer {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: SmolTautomerData

  # User-defined tags.
  tags: [String!]!
}

type SmolTautomerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolTautomerEdge!]!

  # A list of nodes.
  nodes: [SmolTautomer!]!
  totalCount: Int!
}

type SmolTautomerData {
  inchi: String!
  name: String
}

input SmolTautomerDataInput {
  inchi: String!
}

# An edge in a connection.
type SmolTautomerEdge {
  # The item at the end of the edge
  node: SmolTautomer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolTautomerFilterBy {
  and: [SmolTautomerFilterBy!]
  or: [SmolTautomerFilterBy!]
  not: SmolTautomerFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input SmolTautomerSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type StatusByAccount {
  created_at: DateTime!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByAccountEdge {
  # The item at the end of the edge
  node: StatusByAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByName {
  created_at: DateTime!
  name: String!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccount {
  created_at: DateTime!
  name: String!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameAndAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByNameAndAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameAndAccountEdge {
  # The item at the end of the edge
  node: StatusByNameAndAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByNameConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameEdge!]!

  # A list of nodes.
  nodes: [StatusByName!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameEdge {
  # The item at the end of the edge
  node: StatusByName!

  # A cursor for use in pagination
  cursor: String!
}

type Structure {
  id: EntityId!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  # System-defined data that is directly accessible to users.
  data: StructureData

  # User-defined tags.
  tags: [String!]!
  topology: Topology!
  signed_url: JSON!
}

type StructureConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StructureEdge!]!

  # A list of nodes.
  nodes: [Structure!]!
  totalCount: Int!
}

type StructureData {
  name: String!
  topology: TopologyObject!
}

# An edge in a connection.
type StructureEdge {
  # The item at the end of the edge
  node: Structure!

  # A cursor for use in pagination
  cursor: String!
}

input StructureFilterBy {
  and: [StructureFilterBy!]
  or: [StructureFilterBy!]
  not: StructureFilterBy
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  tags: TagFilter
  project_id: UuidFilter
}

input StructureSortBy {
  id: Order
  created_at: Order
  updated_at: Order
  deleted_at: Order
}

type Subscription {
  stream(argumentId: ArgumentId!): JSON!
}

type Tag {
  tag: String!
  created_at: DateTime!
  count: Int!
}

type TagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TagEdge!]!

  # A list of nodes.
  nodes: [Tag!]!
  totalCount: Int!
}

# An edge in a connection.
type TagEdge {
  # The item at the end of the edge
  node: Tag!

  # A cursor for use in pagination
  cursor: String!
}

input TagFilter {
  all: [String!]
  any: [String!]
}

input TestCase {
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget!
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

type Token {
  id: TokenId!
  created_at: DateTime!
  deleted_at: DateTime
  user_id: UserId!
}

type TokenConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TokenEdge!]!

  # A list of nodes.
  nodes: [Token!]!
  totalCount: Int!
}

# An edge in a connection.
type TokenEdge {
  # The item at the end of the edge
  node: Token!

  # A cursor for use in pagination
  cursor: String!
}

scalar TokenId

# An structure-of-arrays based representation of coordinates, charges and bonds between atoms, with utilty functions to manipulate them.
# # Example
# ```
# use qdx_common::{Bond, Topology};
# Topology {
# symbols: vec!["H".into(), "O".into(), "H".into()],
# geometry: vec![0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# connectivity: Some(vec![Bond(0,1,1), Bond(1,2,1)]),
# atom_charges: Some(vec![0,0,0]),
# partial_charges: None,
# atom_labels: None,
# fragments: Some(vec![vec![0,1,2]]),
# fragment_charges: Some(vec![0]),
# fragment_multiplicities: Some(vec![1]),
# alts: None,
# };
# /* JSON
# {
# "symbols": ["H", "O", "H"],
# "geometry": [0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# "connectivity": [[0,1,1], [1,2,1]],
# "atom_charges": [0,0,0],
# "fragments": [[0,1,2]],
# "fragment_charges": [0]
# "fragment_multiplicities": [1]
# }
# */
# ```
type Topology {
  # Atomic symbols of elements
  symbols: [String!]!

  # Flat vector of X,Y,Z coordinates for atoms in Angstroms
  geometry: [Float!]!

  # Bonds between atoms
  connectivity: [Bond!]

  # Formal charges for each atom
  atom_charges: [Int!]
  partial_charges: [Float!]
  atom_labels: [String!]

  # A list of fragments, where each fragment is a list of atom indices
  fragments: [[Int!]!]

  # A list of sums of all atom formal charges for each fragment
  fragment_charges: [Int!]

  # A list of multiplicities for each fragment
  fragment_multiplicities: [Int!]
  alts: [Alt!]
}

# An structure-of-arrays based representation of coordinates, charges and bonds between atoms, with utilty functions to manipulate them.
# # Example
# ```
# use qdx_common::{Bond, Topology};
# Topology {
# symbols: vec!["H".into(), "O".into(), "H".into()],
# geometry: vec![0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# connectivity: Some(vec![Bond(0,1,1), Bond(1,2,1)]),
# atom_charges: Some(vec![0,0,0]),
# partial_charges: None,
# atom_labels: None,
# fragments: Some(vec![vec![0,1,2]]),
# fragment_charges: Some(vec![0]),
# fragment_multiplicities: Some(vec![1]),
# alts: None,
# };
# /* JSON
# {
# "symbols": ["H", "O", "H"],
# "geometry": [0.0,0.0,0.0,
# 1.0,0.0,0.0,
# 1.0,1.0,0.0],
# "connectivity": [[0,1,1], [1,2,1]],
# "atom_charges": [0,0,0],
# "fragments": [[0,1,2]],
# "fragment_charges": [0]
# "fragment_multiplicities": [1]
# }
# */
# ```
input TopologyInput {
  # Atomic symbols of elements
  symbols: [String!]!

  # Flat vector of X,Y,Z coordinates for atoms in Angstroms
  geometry: [Float!]!

  # Bonds between atoms
  connectivity: [Bond!]

  # Formal charges for each atom
  atom_charges: [Int!]
  partial_charges: [Float!]
  atom_labels: [String!]

  # A list of fragments, where each fragment is a list of atom indices
  fragments: [[Int!]!]

  # A list of sums of all atom formal charges for each fragment
  fragment_charges: [Int!]

  # A list of multiplicities for each fragment
  fragment_multiplicities: [Int!]
  alts: [Alt!]
}

scalar TopologyObject

scalar Type

# A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
# Strings within GraphQL. UUIDs are used to assign unique identifiers to
# entities without requiring a central allocating authority.
#
# # References
#
# * [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
# * [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
scalar UUID

input UpdateModuleInstanceInput {
  id: ModuleInstanceId!
  path: String
  ins: [ArgumentInput!]
  outs: [ArgumentInput!]
  target: ModuleInstanceTarget
  status: ModuleInstanceStatus
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

scalar Upload

type User {
  id: UserId!
  created_at: DateTime!
  account_id: AccountId!
  account: Account!
  tokens(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): TokenConnection!
}

scalar UserId

input UuidFilter {
  eq: UUID
  ne: UUID
  in: [UUID!]
}
