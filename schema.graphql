# Indicates that an Input Object is a OneOf Input Object (and thus requires
#                         exactly one of its field be provided)
directive @oneOf on INPUT_OBJECT

type Account {
  id: AccountId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  tier: AccountTier!
  config: AccountConfig
  object_descriptor(id: ObjectDescriptorId!): ObjectDescriptor!
  object_descriptors(
    after: String
    before: String
    first: Int
    last: Int
    filter: ObjectDescriptorFilter
    sort: ObjectDescriptorSort
  ): ObjectDescriptorConnection!
  project(id: ProjectId!): Project!
  projects(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProjectFilter
    sort: ProjectSort
  ): ProjectConnection!
  resource_utilization(
    from: DateTime
    to: DateTime
  ): [ResourceUtilizationReport!]!
  module_instances(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    status: ModuleInstanceStatus
    target: ModuleInstanceTarget
    tags: [String!]
    ids: [ModuleInstanceId!]
    deleted: Boolean
    in_arguments: [ArgumentId!]
  ): SimpleModuleInstanceConnection!

  # Get all tags placed on module_instances
  module_instance_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
    min_count: Int
  ): V1TagConnection!
  arguments(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    ids: [ArgumentId!]
    typeinfo: [Type!]
    typequery: [TypeQuery!]
    tags: [String!]
    resolved: Boolean
    deleted: Boolean
  ): ArgumentConnection!

  # Get all tags placed on module_instances
  argument_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
  ): V1TagConnection!
}

type AccountBucketConfig {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

input AccountBucketConfigInput {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

type AccountConfig {
  config_account: AccountId
  bucket_config: AccountBucketConfig
}

input AccountConfigInput {
  config_account: AccountId
  bucket_config: AccountBucketConfigInput
}

scalar AccountId

enum AccountTier {
  FREE
  PRO
  STARTUP
  ACADEMIC
  ENTERPRISE
}

type Argument {
  id: ArgumentId!
  name: String
  created_at: DateTime!
  deleted_at: DateTime
  rejected_at: DateTime
  resolved_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  tags: [String!]
  source: ModuleInstanceId
}

type ArgumentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ArgumentEdge!]!

  # A list of nodes.
  nodes: [Argument!]!
  totalCount: Int!
}

# An edge in a connection.
type ArgumentEdge {
  # The item at the end of the edge
  node: Argument!

  # A cursor for use in pagination
  cursor: String!
}

scalar ArgumentId

input ArgumentInput {
  id: ArgumentId
  name: String
  tags: [String!]
  value: JSON
}

input CreateProjectInput {
  name: String
  description: String
  tags: [String!]
}

input CreateProteinConformerInput {
  project_id: ProjectId!
  protein_id: ProteinId!
  structure_id: StructureId!
  name: String
  description: String
  tags: [String!]
}

input CreateProteinInput {
  sequence: String!
  project_id: ProjectId!
  name: String
  description: String
  tags: [String!]
}

input CreateRun {
  # Rex expression to run.
  rex: String
  expr: JSON
  project_id: ProjectId!

  # Optional mapping of modules to their full path versions.
  module_lock: JSONObject
  name: String
  description: String
  tags: [String!]
}

input CreateSmolConformerInput {
  project_id: ProjectId!
  smol_id: SmolId!
  structure_id: StructureId!
  name: String
  description: String
  tags: [String!]
}

input CreateSmolInput {
  smi: String
  inchi: String
  project_id: ProjectId!
  name: String
  description: String
  tags: [String!]
}

input CreateStructureInput {
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  project_id: ProjectId!
  name: String
  description: String
  tags: [String!]
}

input CreateTagInput {
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
  project_id: ProjectId!
  name: String
  description: String
  tags: [String!]
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  ne: DateTime
  gt: DateTime
  ge: DateTime
  lt: DateTime
  le: DateTime
}

enum DateTimeSort {
  asc
  desc
}

type GlobalStatus {
  created_at: DateTime!
  status: ModuleInstanceStatus!
  count: Int!
}

type GlobalStatusConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [GlobalStatusEdge!]!

  # A list of nodes.
  nodes: [GlobalStatus!]!
  totalCount: Int!
}

# An edge in a connection.
type GlobalStatusEdge {
  # The item at the end of the edge
  node: GlobalStatus!

  # A cursor for use in pagination
  cursor: String!
}

input I64Filter {
  eq: Int
  ne: Int
  gt: Int
  ge: Int
  lt: Int
  le: Int
}

# A scalar that can represent any JSON value.
scalar JSON

# A scalar that can represent any JSON Object value.
scalar JSONObject

type LogEntry {
  id: String!
  part: Int!
  created_at: DateTime!
  content: [String!]!
}

type LogEntryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [LogEntryEdge!]!

  # A list of nodes.
  nodes: [LogEntry!]!
  totalCount: Int!
}

# An edge in a connection.
type LogEntryEdge {
  # The item at the end of the edge
  node: LogEntry!

  # A cursor for use in pagination
  cursor: String!
}

# Units for memory and storage
enum MemUnits {
  B
  KB
  MB
  GB
  TB
}

input MetadataFilter {
  all: [MetadataFilter!]
  any: [MetadataFilter!]
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  name: StringFilter
  description: StringFilter
  tags: TagFilter
}

input MetadataSort {
  created_at: DateTimeSort
  updated_at: DateTimeSort
  deleted_at: DateTimeSort
  name: StringSort
  description: StringSort
}

type Module {
  # Unique identifier for module
  id: ModuleId!
  created_at: DateTime!

  # When the module was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # Path to module, used for resolving the module entrypoint
  path: String!

  # Name of module, used for display + search purposes. Will strip _tengu / tengu_ from the path
  name: String!

  # The types of the module's inputs
  ins: [Type!]!

  # The types of the module's outputs
  outs: [Type!]!

  # Tags to apply to the module
  tags: [String!]

  # Description of module
  description: String

  # Usage instructions for module - NOTE: this is deprecated, use ins_usage and outs_usage instead
  usage: String

  # Usage instructions for module inputs
  ins_usage: [String!]

  # Usage instructions for module outputs
  outs_usage: [String!]

  # Targets that this module can be dispatched to
  targets: [ModuleInstanceTarget!]

  # Resource specification indicating bounds on the resources required by this module
  resource_bounds: ResourceBounds
  typedesc: String!
}

type ModuleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModuleEdge!]!

  # A list of nodes.
  nodes: [Module!]!
  totalCount: Int!
}

# An edge in a connection.
type ModuleEdge {
  # The item at the end of the edge
  node: Module!

  # A cursor for use in pagination
  cursor: String!
}

type ModuleFailureContext {
  stderr: String
  stdout: String
  syserr: String
}

enum ModuleFailureReason {
  # Module arguments failed to resolve
  RESOLUTION

  # Module failed to dispatch to a cluster
  DISPATCH

  # Module failed during execution
  RUN

  # Module instance has not made any progress for a given timeout.
  STALLED

  # Module instance can not be found on the cluster it was dispatched to.
  MISSING

  # Module instance has been corrupted and does not have a valid status.
  CORRUPTED
}

scalar ModuleId

input ModuleInput {
  path: String!
  tags: [String!]
  tests: [TestCase!]!
}

type ModuleInstance {
  # Unique identifier for module instance
  id: ModuleInstanceId!

  # When the module instance was created
  created_at: DateTime!

  # When the module instance was deleted, is used to determine if a module instance is soft-deleted
  deleted_at: DateTime

  # Account that created the module instance
  account_id: AccountId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # The arguments that will be passed to the module instance
  ins: [Argument!]!

  # The arguments that will be produced by the module instance
  outs: [Argument!]!

  # Name of the module instance
  name: String

  # When the module entered the QUEUED state
  queued_at: DateTime

  # When the module entered the ADMITTED state
  admitted_at: DateTime

  # When the module entered the DISPATCHED state
  dispatched_at: DateTime

  # When the module entered the RUNNING state
  run_at: DateTime

  # When the module entered the COMPLETED or FAILED state
  completed_at: DateTime

  # Module failure category
  failure_reason: ModuleFailureReason

  # Module failure context, useful for debugging
  failure_context: ModuleFailureContext

  # Current module instance status
  status: ModuleInstanceStatus!

  # Target that this module instance will be / is dispatched to
  target: ModuleInstanceTarget!

  # Resources allocated to this module instance
  resources: ModuleInstanceResources

  # Progress of the module instance
  progress: ModuleInstanceProgress

  # Tags applied to the module instance
  tags: [String!]

  # Runtime account that the module instance is configured to use
  config_account: AccountId
  module: Module!
  stdout(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  stderr(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  resource_utilization: ResourceUtilization
}

scalar ModuleInstanceId

input ModuleInstanceInput {
  path: String!
  args: [ArgumentInput!]!
  name: String
  target: ModuleInstanceTarget

  # Resource specification
  resources: ModuleInstanceResourcesInput

  # Tags to place on the module instance
  tags: [String!]

  # Tags to apply to the outputs
  out_tags: [[String!]]

  # Tags to apply to the outputs
  out_names: [String]

  # Is this the final module intance in the pipeline?
  end: Boolean
}

type ModuleInstanceProgress {
  n: Int!
  n_expected: Int!
  n_max: Int!
  done: Boolean!
}

type ModuleInstanceResources {
  # Number of gpus to be allocated to job
  gpus: Int

  # Minimum amount of gpu memory required per gpu, denominate in gpu_mem_units
  gpu_mem: Int

  # Unit of gpu memory, defaults to B
  gpu_mem_units: MemUnits

  # Number of cpus to be allocated to job
  cpus: Int

  # Number of nodes to be allocated to job
  nodes: Int

  # Amount of RAM to be allocated to job, denominated in mem_units
  mem: Int

  # Units for RAM, defaults to B
  mem_units: MemUnits

  # Space to be allocated on the target denominated in storage_units, must be > the size of Object inputs.
  # The runtime will ensure this amount of space is reserved on the target, so try to take the output
  # size into account so that the target does not run out of space.
  storage: Int

  # Units for storage, defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int
  storage_mounts: [String!]
}

input ModuleInstanceResourcesInput {
  # Number of gpus to be allocated to job
  gpus: Int

  # Minimum amount of gpu memory required per gpu, denominate in gpu_mem_units
  gpu_mem: Int

  # Unit of gpu memory, defaults to B
  gpu_mem_units: MemUnits

  # Number of cpus to be allocated to job
  cpus: Int

  # Number of nodes to be allocated to job
  nodes: Int

  # Amount of RAM to be allocated to job, denominated in mem_units
  mem: Int

  # Units for RAM, defaults to B
  mem_units: MemUnits

  # Space to be allocated on the target denominated in storage_units, must be > the size of Object inputs.
  # The runtime will ensure this amount of space is reserved on the target, so try to take the output
  # size into account so that the target does not run out of space.
  storage: Int

  # Units for storage, defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int
  storage_mounts: [String!]
}

enum ModuleInstanceStatus {
  # Module instance has been created.
  CREATED

  # Module instance is waiting for its arguments to be resolved. It will be admitted once all of its
  # dependencies have been resolved (meaning that the module instances that
  # will produce these dependencies have completed).
  RESOLVING

  # Module instance has been admitted. It will be dispatched when a cluster
  # becomes available.
  ADMITTED

  # Module instance has been dispatched to run on a cluster. This will run
  # the module instance until it is done or until it yields.
  DISPATCHED

  # Module instance is queued on the cluster. It will start running once the cluster's internal
  # queue launches it.
  QUEUED

  # Module instance is running and making progress on the cluster.
  RUNNING

  # Module has finished calculation, but result upload still pending.
  # We can dispatch more jobs, but cannot complete the module instance until the upload is complete.
  AWAITING_UPLOAD

  # Module instance has been run to completion.
  COMPLETED

  # Module instance failed to run.
  FAILED

  # Module instance was cancelled.
  CANCELLED
}

enum ModuleInstanceTarget {
  TINY
  GADI
  BULLET
  BULLET_2
  BULLET_3
  BULLET_4
  SETONIX
  GADI_GPU
  BULLET_GPU
  BULLET_2_GPU
  BULLET_3_GPU
  BULLET_4_GPU
  SETONIX_GPU
  GADI_EXPRESS
  SETONIX_EXPRESS
}

type Mutation {
  login(username: String!, password: String!): User
  deploy(module: ModuleInput!): SimpleModule!
  destroy(module: ModuleId!): SimpleModule!
  delete_argument(arg_id: ArgumentId!): Argument!
  delete_module_instance(module: ModuleInstanceId!): SimpleModuleInstance!
  delete_token(token_id: TokenId!): Token!
  rename(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    name: String
  ): [String!]!
  tag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  untag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  upload_large_object(
    typeinfo: JSON!
    format: ObjectFormat!
  ): ObjectDescriptorWithUploadUrl!
  upload_object(
    file: Upload!
    typeinfo: JSON!
    format: ObjectFormat!
  ): ObjectDescriptor!

  # Cancel a currently running instance, but don't delete it
  cancel(instance: ModuleInstanceId!): ModuleInstanceId!

  # If a module instance fails due to environment issues (eg. inputs and module are valid),
  # this method can be used to retry the module instance.
  retry(
    instance: ModuleInstanceId!
    target: ModuleInstanceTarget
    resources: ModuleInstanceResourcesInput
  ): SimpleModuleInstance!

  # Run a module instance
  run(instance: ModuleInstanceInput!): SimpleModuleInstance!

  # An (admin) endpoint to update all attributes of a module instance.
  # Only to be used in debug / rescue situations.
  update_module_instance(
    instance_update: UpdateModuleInstanceInput!
  ): SimpleModuleInstance!

  # Track historical utilization
  track_module_instance_resource_utilization(
    utilization: ResourceUtilizationInput!
  ): ResourceUtilization!
  create_argument(
    name: String
    typeinfo: JSON!
    tags: [String!]
    value: JSON!
  ): Argument!
  create_token: Token!
  eval(input: CreateRun!): Run!
  create_project(input: CreateProjectInput!): Project!
  create_tag(input: CreateTagInput!): Tag!
  create_protein_conformer(
    input: CreateProteinConformerInput!
  ): ProteinConformer!
  create_protein(input: CreateProteinInput!): Protein!
  create_smol_conformer(input: CreateSmolConformerInput!): SmolConformer!
  create_smol(input: CreateSmolInput!): Smol!
  create_structure(input: CreateStructureInput!): Structure!
  update_account_config(
    account_id: AccountId!
    input: AccountConfigInput!
  ): AccountConfig!
  update_account_tier(account_id: AccountId!, tier: AccountTier!): AccountTier!
}

type Object {
  object_descriptor: ObjectDescriptor!
  contents: JSON!
  url: String!
}

type ObjectDescriptor {
  id: ObjectDescriptorId!
  object: VirtualObject!
  type_info: Type!
  base_url: String!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
}

type ObjectDescriptorConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ObjectDescriptorEdge!]!

  # A list of nodes.
  nodes: [ObjectDescriptor!]!
  total_count: Int!
}

# An edge in a connection.
type ObjectDescriptorEdge {
  # The item at the end of the edge
  node: ObjectDescriptor!

  # A cursor for use in pagination
  cursor: String!
}

input ObjectDescriptorFilter {
  all: [ObjectDescriptorFilter!]
  any: [ObjectDescriptorFilter!]
  id: UuidFilter
  object: VirtualObjectFilter
  base_url: StringFilter
  account_id: UuidFilter
  metadata: MetadataFilter
}

scalar ObjectDescriptorId

input ObjectDescriptorSort {
  id: UuidSort
  object: VirtualObjectSort
  base_url: StringSort
  account_id: UuidSort
  metadata: MetadataSort
}

type ObjectDescriptorWithUploadUrl {
  descriptor: ObjectDescriptor!
  upload_url: String!
}

enum ObjectFormat {
  json
  bin
}

input ObjectFormatFilter {
  eq: ObjectFormat
  ne: ObjectFormat
}

enum OrderBy {
  ASC
  DESC
}

# Information about pagination in a connection
type PageInfo {
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

type Project {
  id: ProjectId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
  protein_conformer(id: ProteinConformerId!): ProteinConformer!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort_by: ProteinConformerSort
  ): ProteinConformerConnection!
  protein(id: ProteinId!): Protein!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilter
    sort_by: ProteinSort
  ): ProteinConnection!
  smol_conformer(id: SmolConformerId!): SmolConformer!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort_by: SmolConformerSort
  ): SmolConformerConnection!
  smol(id: SmolId!): Smol!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilter
    sort_by: SmolSort
  ): SmolConnection!
  structure(id: StructureId!): Structure!
  run(id: RunId!): Run!
  runs(
    after: String
    before: String
    first: Int
    last: Int
    filter: RunFilter
    sort_by: RunSort
  ): RunConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilter
    sort_by: StructureSort
  ): StructureConnection!
}

type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProjectEdge!]!

  # A list of nodes.
  nodes: [Project!]!
  total_count: Int!
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge
  node: Project!

  # A cursor for use in pagination
  cursor: String!
}

input ProjectFilter {
  all: [ProjectFilter!]
  any: [ProjectFilter!]
  id: UuidFilter
  account_id: UuidFilter
  metadata: MetadataFilter
}

scalar ProjectId

input ProjectSort {
  id: UuidSort
  account_id: UuidSort
  metadata: MetadataSort
}

type Protein {
  id: ProteinId!
  sequence: String!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort_by: ProteinConformerSort
  ): ProteinConformerConnection!
}

type ProteinConformer {
  id: ProteinConformerId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
  structure: Structure!
}

type ProteinConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinConformerEdge!]!

  # A list of nodes.
  nodes: [ProteinConformer!]!
  total_count: Int!
}

# An edge in a connection.
type ProteinConformerEdge {
  # The item at the end of the edge
  node: ProteinConformer!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinConformerFilter {
  all: [ProteinConformerFilter!]
  any: [ProteinConformerFilter!]
  id: UuidFilter
  account_id: UuidFilter
  project_id: UuidFilter
  protein_id: UuidFilter
  structure_id: UuidFilter
  metadata: MetadataFilter
}

scalar ProteinConformerId

input ProteinConformerSort {
  id: UuidSort
  account_id: UuidSort
  project_id: UuidSort
  protein_id: UuidSort
  structure_id: UuidSort
  metadata: MetadataSort
}

type ProteinConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinEdge!]!

  # A list of nodes.
  nodes: [Protein!]!
  total_count: Int!
}

# An edge in a connection.
type ProteinEdge {
  # The item at the end of the edge
  node: Protein!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinFilter {
  all: [ProteinFilter!]
  any: [ProteinFilter!]
  id: UuidFilter
  sequence: StringFilter
  project_id: UuidFilter
  account_id: UuidFilter
  metadata: MetadataFilter
}

scalar ProteinId

input ProteinSort {
  id: UuidSort
  sequence: StringSort
  project_id: UuidSort
  account_id: UuidSort
  metadata: MetadataSort
}

type Query {
  modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    path: String
    name: String
    deleted: Boolean
    tags: [String!]
  ): ModuleConnection!
  latest_modules(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    names: [String!]
    targets: [ModuleInstanceTarget!]
  ): ModuleConnection!
  me: User!
  status_by_name(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameConnection!
  status_by_name_and_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByNameAndAccountConnection!
  status_by_account(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): StatusByAccountConnection!
  global_status(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): GlobalStatusConnection!
  utilization_for_target(
    target: ModuleInstanceTarget!
    from: DateTime
    to: DateTime
  ): ResourceUtilizationReport!
  module(id: ModuleId!): Module!
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  argument(id: ArgumentId!): Argument!
  object(id: ObjectDescriptorId!): Object!
  object_path(path: UUID!): Object!
}

# Validation and hints to resources to use for an instance.
type ResourceBounds {
  # number of gpus in node, None means no gpu required.
  gpu_min: Int

  # max number of gpus in node that can used, 0 means no gpu support.
  gpu_max: Int

  # optimal number of gpus in node
  gpu_hint: Int

  # minimum gpu memory required in MB per gpu
  gpu_mem_min: Int

  # maxmimum memory that can be used in MB (None means no limit)
  gpu_mem_max: Int

  # optimal gpu memory in MB
  gpu_mem_hint: Int

  # minimum number of cpus required, should be > 0 if Some
  cpu_min: Int

  # maximum number of cpus that can be used, 0 means no limit
  cpu_max: Int

  # optimal number of cpus
  cpu_hint: Int

  # minimum node count
  node_min: Int

  # maximum node count (e.g. maximum node parallelism)
  node_max: Int

  # most optimal node count
  node_hint: Int
  mem_min: Int
  mem_max: Int

  # in MB
  storage_min: Int

  # in MB (0 means no limit)
  storage_max: Int
}

type ResourceUtilization {
  id: ResourceUtilizationId!
  created_at: DateTime!
  module_instance_id: ModuleInstanceId!
  target: ModuleInstanceTarget!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

scalar ResourceUtilizationId

input ResourceUtilizationInput {
  moduleInstanceId: ModuleInstanceId!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

type ResourceUtilizationReport {
  target: ModuleInstanceTarget!
  from: DateTime!
  to: DateTime!
  gpu_avg: Float
  mem_avg: Float
  storage_total: Float!
  storage_avg: Float!
  walltime_total: Float!
  walltime_avg: Float!
  cputime_total: Float!
  cputime_avg: Float!
  inodes_total: Float!
  sus_total: Int
}

type Run {
  id: RunId!
  expr: JSON!
  result: JSON
  trace: JSON
  module_lock: JSONObject!
  status: RunStatus!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
}

type RunConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RunEdge!]!

  # A list of nodes.
  nodes: [Run!]!
  total_count: Int!
}

# An edge in a connection.
type RunEdge {
  # The item at the end of the edge
  node: Run!

  # A cursor for use in pagination
  cursor: String!
}

input RunFilter {
  all: [RunFilter!]
  any: [RunFilter!]
  id: UuidFilter
  status: RunStatusFilter
  project_id: UuidFilter
  account_id: UuidFilter
  metadata: MetadataFilter
}

scalar RunId

input RunSort {
  id: UuidSort
  project_id: UuidSort
  account_id: UuidSort
  metadata: MetadataSort
}

enum RunStatus {
  PENDING
  RUNNING
  DONE
  ERROR
}

input RunStatusFilter {
  eq: RunStatus
  ne: RunStatus
}

# A module defines an interface to a program that can be run on a cluster.
# It is a wrapper around a computational-chemistry program that defines well-typed inputs and outputs,
# as well as resource requirements and documentation.
type SimpleModule {
  # Unique identifier for module
  id: ModuleId!

  # When the module was created
  created_at: DateTime!

  # When the module was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # Path to module, used for resolving the module entrypoint
  path: String!

  # Name of module, used for display + search purposes. Will strip _tengu / tengu_ from the path
  name: String!

  # The types of the module's inputs
  ins: [Type!]!

  # The types of the module's outputs
  outs: [Type!]!

  # Tags to apply to the module
  tags: [String!]

  # Description of module
  description: String

  # Usage instructions for module - NOTE: this is deprecated, use ins_usage and outs_usage instead
  usage: String

  # Usage instructions for module inputs
  ins_usage: [String!]

  # Usage instructions for module outputs
  outs_usage: [String!]

  # Targets that this module can be dispatched to
  targets: [ModuleInstanceTarget!]

  # Resource specification indicating bounds on the resources required by this module
  resource_bounds: ResourceBounds
}

# A module instance is a single invocation of a module. It is created when a user submits a module
# Can be thought of as a "job"
type SimpleModuleInstance {
  # Unique identifier for module instance
  id: ModuleInstanceId!

  # When the module instance was created
  created_at: DateTime!

  # When the module instance was deleted, is used to determine if a module instance is soft-deleted
  deleted_at: DateTime

  # Account that created the module instance
  account_id: AccountId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # The arguments that will be passed to the module instance
  ins: [Argument!]!

  # The arguments that will be produced by the module instance
  outs: [Argument!]!

  # Name of the module instance
  name: String

  # When the module entered the QUEUED state
  queued_at: DateTime

  # When the module entered the ADMITTED state
  admitted_at: DateTime

  # When the module entered the DISPATCHED state
  dispatched_at: DateTime

  # When the module entered the RUNNING state
  run_at: DateTime

  # When the module entered the COMPLETED or FAILED state
  completed_at: DateTime

  # Module failure category
  failure_reason: ModuleFailureReason

  # Module failure context, useful for debugging
  failure_context: ModuleFailureContext

  # Current module instance status
  status: ModuleInstanceStatus!

  # Target that this module instance will be / is dispatched to
  target: ModuleInstanceTarget!

  # Resources allocated to this module instance
  resources: ModuleInstanceResources

  # Progress of the module instance
  progress: ModuleInstanceProgress

  # Tags applied to the module instance
  tags: [String!]

  # Runtime account that the module instance is configured to use
  config_account: AccountId
}

type SimpleModuleInstanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SimpleModuleInstanceEdge!]!

  # A list of nodes.
  nodes: [SimpleModuleInstance!]!
  totalCount: Int!
}

# An edge in a connection.
type SimpleModuleInstanceEdge {
  # The item at the end of the edge
  node: SimpleModuleInstance!

  # A cursor for use in pagination
  cursor: String!
}

type Smol {
  id: SmolId!
  smi: String
  inchi: String
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort_by: SmolConformerSort
  ): SmolConformerConnection!
}

type SmolConformer {
  id: SmolConformerId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
  structure: Structure!
}

type SmolConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolConformerEdge!]!

  # A list of nodes.
  nodes: [SmolConformer!]!
  total_count: Int!
}

# An edge in a connection.
type SmolConformerEdge {
  # The item at the end of the edge
  node: SmolConformer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolConformerFilter {
  all: [SmolConformerFilter!]
  any: [SmolConformerFilter!]
  id: UuidFilter
  account_id: UuidFilter
  project_id: UuidFilter
  smol_id: UuidFilter
  structure_id: UuidFilter
  metadata: MetadataFilter
}

scalar SmolConformerId

input SmolConformerSort {
  id: UuidSort
  account_id: UuidSort
  project_id: UuidSort
  smol_id: UuidSort
  structure_id: UuidSort
  metadata: MetadataSort
}

type SmolConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolEdge!]!

  # A list of nodes.
  nodes: [Smol!]!
  total_count: Int!
}

# An edge in a connection.
type SmolEdge {
  # The item at the end of the edge
  node: Smol!

  # A cursor for use in pagination
  cursor: String!
}

input SmolFilter {
  all: [SmolFilter!]
  any: [SmolFilter!]
  id: UuidFilter
  smi: StringFilter
  inchi: StringFilter
  project_id: UuidFilter
  account_id: UuidFilter
  metadata: MetadataFilter
}

scalar SmolId

input SmolSort {
  id: UuidSort
  smi: StringSort
  inchi: StringSort
  project_id: UuidSort
  account_id: UuidSort
  metadata: MetadataSort
}

type StatusByAccount {
  created_at: DateTime!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByAccountEdge {
  # The item at the end of the edge
  node: StatusByAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByName {
  created_at: DateTime!
  name: String!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccount {
  created_at: DateTime!
  name: String!
  account_id: AccountId!
  status: ModuleInstanceStatus!
  count: Int!
}

type StatusByNameAndAccountConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameAndAccountEdge!]!

  # A list of nodes.
  nodes: [StatusByNameAndAccount!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameAndAccountEdge {
  # The item at the end of the edge
  node: StatusByNameAndAccount!

  # A cursor for use in pagination
  cursor: String!
}

type StatusByNameConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StatusByNameEdge!]!

  # A list of nodes.
  nodes: [StatusByName!]!
  totalCount: Int!
}

# An edge in a connection.
type StatusByNameEdge {
  # The item at the end of the edge
  node: StatusByName!

  # A cursor for use in pagination
  cursor: String!
}

input StringFilter {
  eq: String
  ne: String
  gt: String
  ge: String
  lt: String
  le: String
  like: String
  in: [String!]
}

enum StringSort {
  asc
  desc
}

type Structure {
  id: StructureId!
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
}

type StructureConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StructureEdge!]!

  # A list of nodes.
  nodes: [Structure!]!
  total_count: Int!
}

# An edge in a connection.
type StructureEdge {
  # The item at the end of the edge
  node: Structure!

  # A cursor for use in pagination
  cursor: String!
}

input StructureFilter {
  all: [StructureFilter!]
  any: [StructureFilter!]
  id: UuidFilter
  rcsb_id: StringFilter
  account_id: UuidFilter
  project_id: UuidFilter
  metadata: MetadataFilter
}

scalar StructureId

input StructureSort {
  id: UuidSort
  rcsb_id: StringSort
  account_id: UuidSort
  project_id: UuidSort
  metadata: MetadataSort
}

type Subscription {
  stream(argumentId: ArgumentId!): JSON!
}

type Tag {
  id: TagId!
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  name: String
  description: String
  tags: [String!]
}

input TagFilter {
  in: [String!]
}

scalar TagId

enum TaggedType {
  structure
  protein
  protein_conformer
  smol
  smol_conformer
  run
  module
  module_instance
}

input TestCase {
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget!
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

type Token {
  id: TokenId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type TokenConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TokenEdge!]!

  # A list of nodes.
  nodes: [Token!]!
  total_count: Int!
}

# An edge in a connection.
type TokenEdge {
  # The item at the end of the edge
  node: Token!

  # A cursor for use in pagination
  cursor: String!
}

input TokenFilter {
  all: [TokenFilter!]
  any: [TokenFilter!]
  id: UuidFilter
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  user_id: UuidFilter
}

scalar TokenId

input TokenSort {
  id: UuidSort
  created_at: DateTimeSort
  updated_at: DateTimeSort
  deleted_at: DateTimeSort
  user_id: UuidSort
}

scalar Type

input TypeQuery {
  path: [String!]!
  query: JSON!
}

scalar TypedVirtualObject

enum U64Sort {
  asc
  desc
}

# A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
# Strings within GraphQL. UUIDs are used to assign unique identifiers to
# entities without requiring a central allocating authority.
#
# # References
#
# * [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
# * [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
scalar UUID

input UpdateModuleInstanceInput {
  id: ModuleInstanceId!
  path: String
  ins: [ArgumentInput!]
  outs: [ArgumentInput!]
  target: ModuleInstanceTarget
  status: ModuleInstanceStatus
  resources: ModuleInstanceResourcesInput
  tags: [String!]
}

scalar Upload

type User {
  id: UserId!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
  account: Account!
  tokens(
    after: String
    before: String
    first: Int
    last: Int
    filter: TokenFilter
    sortBy: TokenSort
  ): TokenConnection!
}

scalar UserId

input UuidFilter {
  eq: UUID
  ne: UUID
  in: [UUID!]
}

enum UuidSort {
  asc
  desc
}

type V1Tag {
  tag: String!
  created_at: DateTime!
  count: Int!
}

type V1TagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [V1TagEdge!]!

  # A list of nodes.
  nodes: [V1Tag!]!
  totalCount: Int!
}

# An edge in a connection.
type V1TagEdge {
  # The item at the end of the edge
  node: V1Tag!

  # A cursor for use in pagination
  cursor: String!
}

type VirtualObject {
  path: String!
  size: Int!
  format: ObjectFormat!
}

input VirtualObjectFilter {
  path: StringFilter
  size: I64Filter
  format: ObjectFormatFilter
}

input VirtualObjectSort {
  path: StringSort
  size: U64Sort
}
