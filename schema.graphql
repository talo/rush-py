# Indicates that an Input Object is a OneOf Input Object (and thus requires
#                         exactly one of its field be provided)
directive @oneOf on INPUT_OBJECT

type Account {
  id: AccountId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  tier: AccountTier!
  config: AccountConfig
  object_descriptor(id: ObjectDescriptorId!): ObjectDescriptor!
  object_descriptors(
    after: String
    before: String
    first: Int
    last: Int
    filter: ObjectDescriptorFilter
    sort: ObjectDescriptorSort
  ): ObjectDescriptorConnection!
  project(id: ProjectId!): Project!
  projects(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProjectFilter
    sort: ProjectSort
  ): ProjectConnection!
  resource_utilization(
    from: DateTime
    to: DateTime
  ): [ResourceUtilizationReport!]!
  module_instances(
    after: String
    before: String
    first: Int
    last: Int
    sort: ModuleInstanceSort
    filter: ModuleInstanceFilter
  ): ModuleInstanceConnection!

  # DEPRECATED: Will return empty list, to be replaced by the tags endpoint in future
  module_instance_tags(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
    contains: String
    min_count: Int
  ): V1TagConnection!
  arguments(
    after: String
    before: String
    first: Int
    last: Int
    sort: ArgumentSort
    filter: ArgumentFilter
  ): ArgumentConnection!
}

type AccountBucketConfig {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

input AccountBucketConfigInput {
  data_bucket: String!
  log_bucket: String!
  bucket_region: String!
}

type AccountConfig {
  config_account: AccountId
  bucket_config: AccountBucketConfig
}

input AccountConfigInput {
  config_account: AccountId
  bucket_config: AccountBucketConfigInput
}

scalar AccountId

enum AccountTier {
  FREE
  PRO
  STARTUP
  ACADEMIC
  ENTERPRISE
}

type Argument {
  id: ArgumentId!
  rejected_at: DateTime
  resolved_at: DateTime
  account_id: AccountId!
  typeinfo: Type!
  value: JSON
  source: ModuleInstanceId

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
}

type ArgumentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ArgumentEdge!]!

  # A list of nodes.
  nodes: [Argument!]!
  total_count: Int!
}

# An edge in a connection.
type ArgumentEdge {
  # The item at the end of the edge
  node: Argument!

  # A cursor for use in pagination
  cursor: String!
}

input ArgumentFilter {
  all: [ArgumentFilter!]
  any: [ArgumentFilter!]
  id: UuidFilter
  rejected_at: DateTimeFilter
  resolved_at: DateTimeFilter
  account_id: UuidFilter
  source: UuidFilter
  metadata: MetadataFilter
}

scalar ArgumentId

input ArgumentInput {
  id: ArgumentId
  name: String
  tags: [String!]
  value: JSON
}

input ArgumentSort {
  id: UuidSort
  rejected_at: DateTimeSort
  resolved_at: DateTimeSort
  account_id: UuidSort
  metadata: MetadataSort
}

scalar AtomRef

type BindingAffinity {
  id: BindingAffinityId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  affinity: Float!
  affinity_metric: String!
  protein: Protein!
  smol: Smol!
  binding_pose_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseAffinityFilter
    sort: BindingPoseAffinitySort
  ): BindingPoseAffinityConnection!
}

type BindingAffinityConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingAffinityEdge!]!

  # A list of nodes.
  nodes: [BindingAffinity!]!
  total_count: Int!
}

# An edge in a connection.
type BindingAffinityEdge {
  # The item at the end of the edge
  node: BindingAffinity!

  # A cursor for use in pagination
  cursor: String!
}

input BindingAffinityFilter {
  all: [BindingAffinityFilter!]
  any: [BindingAffinityFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  affinity: F64Filter
  affinity_metric: StringFilter
  protein_id: UuidFilter
  smol_id: UuidFilter
}

scalar BindingAffinityId

input BindingAffinitySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  affinity: F64Sort
  affinity_metric: StringSort
  protein_id: UuidSort
  smol_id: UuidSort
}

type BindingPoseAffinity {
  id: BindingPoseAffinityId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  binding_affinity: BindingAffinity!
  binding_pose_conformer: BindingPoseConformer!
}

type BindingPoseAffinityConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingPoseAffinityEdge!]!

  # A list of nodes.
  nodes: [BindingPoseAffinity!]!
  total_count: Int!
}

# An edge in a connection.
type BindingPoseAffinityEdge {
  # The item at the end of the edge
  node: BindingPoseAffinity!

  # A cursor for use in pagination
  cursor: String!
}

input BindingPoseAffinityFilter {
  all: [BindingPoseAffinityFilter!]
  any: [BindingPoseAffinityFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  binding_affinity_id: UuidFilter
  binding_pose_conformer_id: UuidFilter
}

scalar BindingPoseAffinityId

input BindingPoseAffinitySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  binding_affinity_id: UuidSort
  binding_pose_conformer_id: UuidSort
}

type BindingPoseConformer {
  id: BindingPoseConformerId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  smol_conformer: SmolConformer!
  binding_site_conformer: BindingSiteConformer!
  binding_pose_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseAffinityFilter
    sort: BindingPoseAffinitySort
  ): BindingPoseAffinityConnection!
  binding_pose_conformer_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerInteractionsFilter
    sort: BindingPoseConformerInteractionsSort
  ): BindingPoseConformerInteractionsConnection!
}

type BindingPoseConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingPoseConformerEdge!]!

  # A list of nodes.
  nodes: [BindingPoseConformer!]!
  total_count: Int!
}

# An edge in a connection.
type BindingPoseConformerEdge {
  # The item at the end of the edge
  node: BindingPoseConformer!

  # A cursor for use in pagination
  cursor: String!
}

input BindingPoseConformerFilter {
  all: [BindingPoseConformerFilter!]
  any: [BindingPoseConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smol_conformer_id: UuidFilter
  binding_site_conformer_id: UuidFilter
}

scalar BindingPoseConformerId

type BindingPoseConformerInteractions {
  id: BindingPoseConformerInteractionsId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  binding_pose_conformer: BindingPoseConformer!
  binding_site_interactions: BindingSiteInteractions!
}

type BindingPoseConformerInteractionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingPoseConformerInteractionsEdge!]!

  # A list of nodes.
  nodes: [BindingPoseConformerInteractions!]!
  total_count: Int!
}

# An edge in a connection.
type BindingPoseConformerInteractionsEdge {
  # The item at the end of the edge
  node: BindingPoseConformerInteractions!

  # A cursor for use in pagination
  cursor: String!
}

input BindingPoseConformerInteractionsFilter {
  all: [BindingPoseConformerInteractionsFilter!]
  any: [BindingPoseConformerInteractionsFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  binding_pose_conformer_id: UuidFilter
  binding_site_interactions_id: UuidFilter
}

scalar BindingPoseConformerInteractionsId

input BindingPoseConformerInteractionsSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  binding_pose_conformer_id: UuidSort
  binding_site_interactions_id: UuidSort
}

input BindingPoseConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smol_conformer_id: UuidSort
  binding_site_conformer_id: UuidSort
}

type BindingSiteBoundingBox {
  min: Xyzf32!
  max: Xyzf32!
}

input BindingSiteBoundingBoxInput {
  min: Xyzf32!
  max: Xyzf32!
}

type BindingSiteConformer {
  id: BindingSiteConformerId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  bounding_box: BindingSiteBoundingBox!
  surface_atoms: [Int!]
  protein_conformer: ProteinConformer!
  binding_pose_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerFilter
    sort: BindingPoseConformerSort
  ): BindingPoseConformerConnection!
}

type BindingSiteConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingSiteConformerEdge!]!

  # A list of nodes.
  nodes: [BindingSiteConformer!]!
  total_count: Int!
}

# An edge in a connection.
type BindingSiteConformerEdge {
  # The item at the end of the edge
  node: BindingSiteConformer!

  # A cursor for use in pagination
  cursor: String!
}

input BindingSiteConformerFilter {
  all: [BindingSiteConformerFilter!]
  any: [BindingSiteConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_conformer_id: UuidFilter
}

scalar BindingSiteConformerId

type BindingSiteConformerPrediction {
  id: BindingSiteConformerPredictionId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  score: Float!
  probability: Float!
  binding_site_conformer: BindingSiteConformer!
  protein_conformer: ProteinConformer!
}

type BindingSiteConformerPredictionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingSiteConformerPredictionEdge!]!

  # A list of nodes.
  nodes: [BindingSiteConformerPrediction!]!
  total_count: Int!
}

# An edge in a connection.
type BindingSiteConformerPredictionEdge {
  # The item at the end of the edge
  node: BindingSiteConformerPrediction!

  # A cursor for use in pagination
  cursor: String!
}

input BindingSiteConformerPredictionFilter {
  all: [BindingSiteConformerPredictionFilter!]
  any: [BindingSiteConformerPredictionFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  score: F32Filter
  probability: F32Filter
  binding_site_conformer_id: UuidFilter
  protein_conformer_id: UuidFilter
}

scalar BindingSiteConformerPredictionId

input BindingSiteConformerPredictionSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  score: F32Sort
  probability: F32Sort
  binding_site_conformer_id: UuidSort
  protein_conformer_id: UuidSort
}

input BindingSiteConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_conformer_id: UuidSort
}

type BindingSiteInteraction {
  # Kind of interaction between the ligand and the receptor.
  kind: BindingSiteInteractionKind!

  # In pi-stacking interactions what kind of stacking is happening?
  pi_stack_kind: PiStackKind

  # The ligand in the `Assembly` that is interacting with the receptor.
  ligand: ResidueRef!

  # The atom in the ligand that is interacting with the receptor. Ignored
  # for salt bridge and pi-interactions.
  ligand_atom: AtomRef!

  # The co-ordinates of the interaction in the ligand. Often this is the
  # co-ordinate of the `ligand_atom` but it is sometimes different (for
  # example, in pi-stacking interactions).
  ligand_xyz: Xyzf32!

  # The residue in the `Assembly` that is interacting with the ligand.
  receptor_residue: ResidueRef!

  # The atom in the receptor that is interacting with the ligand. Ignored
  # for salt bridge and pi-interactions.
  receptor_atom: AtomRef!

  # The co-ordinates of the interaction in the receptor. Often this is the
  # co-ordinate of the `receptor_atom` but it is sometimes different (for
  # example, in pi-stacking interactions).
  receptor_xyz: Xyzf32!

  # In hydrogen bonds and water bridges is the receptor the hydrogen bond
  # donor?
  receptor_is_donor: Boolean!

  # In pi-cation interactions is the receptor providing the charge?
  receptor_is_charged: Boolean!

  # In salt bridges is the receptor carrying the positive charge?
  receptor_is_positively_charged: Boolean!
}

input BindingSiteInteractionInput {
  # Kind of interaction between the ligand and the receptor.
  kind: BindingSiteInteractionKind!

  # In pi-stacking interactions what kind of stacking is happening?
  pi_stack_kind: PiStackKind

  # The ligand in the `Assembly` that is interacting with the receptor.
  ligand: ResidueRef!

  # The atom in the ligand that is interacting with the receptor. Ignored
  # for salt bridge and pi-interactions.
  ligand_atom: AtomRef!

  # The co-ordinates of the interaction in the ligand. Often this is the
  # co-ordinate of the `ligand_atom` but it is sometimes different (for
  # example, in pi-stacking interactions).
  ligand_xyz: Xyzf32!

  # The residue in the `Assembly` that is interacting with the ligand.
  receptor_residue: ResidueRef!

  # The atom in the receptor that is interacting with the ligand. Ignored
  # for salt bridge and pi-interactions.
  receptor_atom: AtomRef!

  # The co-ordinates of the interaction in the receptor. Often this is the
  # co-ordinate of the `receptor_atom` but it is sometimes different (for
  # example, in pi-stacking interactions).
  receptor_xyz: Xyzf32!

  # In hydrogen bonds and water bridges is the receptor the hydrogen bond
  # donor?
  receptor_is_donor: Boolean!

  # In pi-cation interactions is the receptor providing the charge?
  receptor_is_charged: Boolean!

  # In salt bridges is the receptor carrying the positive charge?
  receptor_is_positively_charged: Boolean!
}

enum BindingSiteInteractionKind {
  UNKNOWN
  HYDROPHOBIC
  HYDROGEN_BOND
  HALOGEN_BOND
  WATER_BRIDGE
  SALT_BRIDGE
  PI_STACK
  PI_CATION
  METAL_COMPLEX
}

type BindingSiteInteractions {
  id: BindingSiteInteractionsId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  residues: [Int!]!
  interactions: [BindingSiteInteraction!]!
  protein: Protein!
  binding_pose_conformer_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerInteractionsFilter
    sort: BindingPoseConformerInteractionsSort
  ): BindingPoseConformerInteractionsConnection!
}

type BindingSiteInteractionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [BindingSiteInteractionsEdge!]!

  # A list of nodes.
  nodes: [BindingSiteInteractions!]!
  total_count: Int!
}

# An edge in a connection.
type BindingSiteInteractionsEdge {
  # The item at the end of the edge
  node: BindingSiteInteractions!

  # A cursor for use in pagination
  cursor: String!
}

input BindingSiteInteractionsFilter {
  all: [BindingSiteInteractionsFilter!]
  any: [BindingSiteInteractionsFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
}

scalar BindingSiteInteractionsId

input BindingSiteInteractionsSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
}

input CreateBindingAffinity {
  name: String
  description: String
  tags: [String!]
  affinity: Float!
  affinity_metric: String!
  protein_id: ProteinId!
  smol_id: SmolId!
  project_id: ProjectId!
}

input CreateBindingPoseAffinity {
  name: String
  description: String
  tags: [String!]
  binding_affinity_id: BindingAffinityId!
  binding_pose_conformer_id: BindingPoseConformerId!
  project_id: ProjectId!
}

input CreateBindingPoseConformer {
  name: String
  description: String
  tags: [String!]
  smol_conformer_id: SmolConformerId!
  binding_site_conformer_id: BindingSiteConformerId!
  project_id: ProjectId!
}

input CreateBindingPoseConformerInteractions {
  name: String
  description: String
  tags: [String!]
  binding_pose_conformer_id: BindingPoseConformerId!
  binding_site_interactions_id: BindingSiteInteractionsId!
  project_id: ProjectId!
}

input CreateBindingSiteConformer {
  name: String
  description: String
  tags: [String!]
  bounding_box: BindingSiteBoundingBoxInput!
  surface_atoms: [Int!]
  protein_conformer_id: ProteinConformerId!
  project_id: ProjectId!
}

input CreateBindingSiteConformerPrediction {
  name: String
  description: String
  tags: [String!]
  score: Float!
  probability: Float!
  binding_site_conformer_id: BindingSiteConformerId!
  protein_conformer_id: ProteinConformerId!
  project_id: ProjectId!
}

input CreateBindingSiteInteractions {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  interactions: [BindingSiteInteractionInput!]!
  protein_id: ProteinId!
  project_id: ProjectId!
}

input CreateMetadata {
  name: String
  description: String
  tags: [String!]
}

input CreateModule {
  path: String!
  tags: [String!]
  tests: [TestCase!]!
}

input CreateModuleInstance {
  path: String!
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget
  resources: ResourcesInput
  status: ModuleInstanceStatus
  metadata: CreateMetadata!
  out_tags: [[String!]]
}

input CreateMultipleSequenceAlignment {
  name: String
  description: String
  tags: [String!]
  a_3m: TypedVirtualObject!
  protein_id: ProteinId!
  project_id: ProjectId!
}

input CreateProject {
  name: String
  description: String
  tags: [String!]
}

input CreateProtein {
  name: String
  description: String
  tags: [String!]
  sequence: String!
  project_id: ProjectId!
}

input CreateProteinConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  protein_id: ProteinId!
  structure_id: StructureId!
  project_id: ProjectId!
}

input CreateResourceUtilization {
  module_instance_id: ModuleInstanceId!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
}

input CreateRun {
  name: String
  description: String
  tags: [String!]

  # Rex expression to run.
  rex: String!

  # Optional mapping of modules to their full path versions.
  module_lock: JSONObject
  project_id: ProjectId!
}

input CreateSmol {
  name: String
  description: String
  tags: [String!]
  smi: String
  inchi: String
  data_blocks: [[String!]!]
  project_id: ProjectId!
}

input CreateSmolConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]!
  smol_id: SmolId!
  structure_id: StructureId!
  project_id: ProjectId!
}

input CreateSmolLibrary {
  name: String
  description: String
  tags: [String!]
  project_id: ProjectId!
}

input CreateSmolLibraryPartition {
  name: String
  description: String
  tags: [String!]
  part_idx: Int!
  part_size: Int!
  structures: TypedVirtualObject
  smiles: TypedVirtualObject!
  data_blocks: TypedVirtualObject!
  smol_library_id: SmolLibraryId!
  project_id: ProjectId!
}

input CreateStructure {
  name: String
  description: String
  tags: [String!]
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  project_id: ProjectId!
}

input CreateTag {
  name: String
  description: String
  tags: [String!]
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
  project_id: ProjectId!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

input DateTimeFilter {
  is_null: Boolean
  eq: DateTime
  ne: DateTime
  gt: DateTime
  ge: DateTime
  lt: DateTime
  le: DateTime
}

enum DateTimeSort {
  asc
  desc
}

input F32Filter {
  eq: Float
  ne: Float
  gt: Float
  ge: Float
  lt: Float
  le: Float
}

enum F32Sort {
  asc
  desc
}

input F64Filter {
  eq: Float
  ne: Float
  gt: Float
  ge: Float
  lt: Float
  le: Float
}

enum F64Sort {
  asc
  desc
}

input I32Filter {
  eq: Int
  ne: Int
  gt: Int
  ge: Int
  lt: Int
  le: Int
}

enum I32Sort {
  asc
  desc
}

input I64Filter {
  eq: Int
  ne: Int
  gt: Int
  ge: Int
  lt: Int
  le: Int
}

# A scalar that can represent any JSON value.
scalar JSON

# A scalar that can represent any JSON Object value.
scalar JSONObject

type LogEntry {
  id: String!
  part: Int!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  content: [String!]!
}

type LogEntryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [LogEntryEdge!]!

  # A list of nodes.
  nodes: [LogEntry!]!
  total_count: Int!
}

# An edge in a connection.
type LogEntryEdge {
  # The item at the end of the edge
  node: LogEntry!

  # A cursor for use in pagination
  cursor: String!
}

# Units for memory and storage
enum MemUnits {
  B
  KB
  MB
  GB
  TB
}

type Metadata {
  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
}

input MetadataFilter {
  all: [MetadataFilter!]
  any: [MetadataFilter!]
  created_at: DateTimeFilter
  updated_at: DateTimeFilter
  deleted_at: DateTimeFilter
  name: StringFilter
  description: StringFilter
  run_id: UuidFilter
  tags: TagFilter
}

input MetadataSort {
  created_at: DateTimeSort
  updated_at: DateTimeSort
  deleted_at: DateTimeSort
  name: StringSort
  description: StringSort
}

# A module defines an interface to a program that can be run on a cluster.
# It is a wrapper around a computational-chemistry program that defines well-typed inputs and outputs,
# as well as resource requirements and documentation.
type Module {
  # Unique identifier for module
  id: ModuleId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # The types of the module's inputs
  ins: [Type!]!

  # The types of the module's outputs
  outs: [Type!]!

  # Usage instructions for module inputs
  ins_usage: [String!]

  # Usage instructions for module outputs
  outs_usage: [String!]

  # Targets that this module can be dispatched to
  targets: [ModuleInstanceTarget!]!

  # Resource specification indicating bounds on the resources required by this module
  resource_bounds: ResourceBounds

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  typedesc: String!
}

type ModuleConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModuleEdge!]!

  # A list of nodes.
  nodes: [Module!]!
  total_count: Int!
}

# An edge in a connection.
type ModuleEdge {
  # The item at the end of the edge
  node: Module!

  # A cursor for use in pagination
  cursor: String!
}

type ModuleFailureContext {
  stderr: String
  stdout: String
  syserr: String
}

enum ModuleFailureReason {
  # Module arguments failed to resolve
  RESOLUTION

  # Module failed to dispatch to a cluster
  DISPATCH

  # Module failed during execution
  RUN

  # Module instance has not made any progress for a given timeout.
  STALLED

  # Module instance can not be found on the cluster it was dispatched to.
  MISSING

  # Module instance has been corrupted and does not have a valid status.
  CORRUPTED
}

input ModuleFailureReasonFilter {
  eq: ModuleFailureReason
  ne: ModuleFailureReason
}

input ModuleFilter {
  all: [ModuleFilter!]
  any: [ModuleFilter!]
  id: UuidFilter
  path: StringFilter
  metadata: MetadataFilter
}

scalar ModuleId

# A module instance is a single invocation of a module. It is created when a user submits a module
# Can be thought of as a "job"
type ModuleInstance {
  # Unique identifier for module instance
  id: ModuleInstanceId!

  # Account that created the module instance
  account_id: AccountId!

  # Path to module, used for resolving the module entrypoint
  path: String!

  # When the module entered the QUEUED state
  queued_at: DateTime

  # When the module entered the ADMITTED state
  admitted_at: DateTime

  # When the module entered the DISPATCHED state
  dispatched_at: DateTime

  # When the module entered the RUNNING state
  run_at: DateTime

  # When the module entered the COMPLETED or FAILED state
  completed_at: DateTime

  # Module failure category
  failure_reason: ModuleFailureReason

  # Module failure context, useful for debugging
  failure_context: ModuleFailureContext

  # Current module instance status
  status: ModuleInstanceStatus!

  # Target that this module instance will be / is dispatched to
  target: ModuleInstanceTarget!

  # Resources allocated to this module instance
  resources: Resources

  # Progress of the module instance
  progress: ProgressEvent

  # Runtime account that the module instance is configured to use
  config_account: AccountId

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  module: Module!
  stdout(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  stderr(
    after: String
    before: String
    first: Int
    last: Int
    order: OrderBy
  ): LogEntryConnection!
  resource_utilization: ResourceUtilization
  ins: [Argument!]!
  outs: [Argument!]!
}

type ModuleInstanceConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ModuleInstanceEdge!]!

  # A list of nodes.
  nodes: [ModuleInstance!]!
  total_count: Int!
}

# An edge in a connection.
type ModuleInstanceEdge {
  # The item at the end of the edge
  node: ModuleInstance!

  # A cursor for use in pagination
  cursor: String!
}

input ModuleInstanceFilter {
  all: [ModuleInstanceFilter!]
  any: [ModuleInstanceFilter!]
  id: UuidFilter
  account_id: UuidFilter
  path: StringFilter
  queued_at: DateTimeFilter
  admitted_at: DateTimeFilter
  dispatched_at: DateTimeFilter
  run_at: DateTimeFilter
  completed_at: DateTimeFilter
  failure_reason: ModuleFailureReasonFilter
  status: ModuleInstanceStatusFilter
  target: ModuleInstanceTargetFilter
  config_account: UuidFilter
  metadata: MetadataFilter
}

scalar ModuleInstanceId

input ModuleInstanceSort {
  id: UuidSort
  path: StringSort
  queued_at: DateTimeSort
  admitted_at: DateTimeSort
  dispatched_at: DateTimeSort
  run_at: DateTimeSort
  completed_at: DateTimeSort
  metadata: MetadataSort
}

enum ModuleInstanceStatus {
  # Module instance has been created.
  CREATED

  # Module instance is waiting for its arguments to be resolved. It will be admitted once all of its
  # dependencies have been resolved (meaning that the module instances that
  # will produce these dependencies have completed).
  RESOLVING

  # Module instance has been admitted. It will be dispatched when a cluster
  # becomes available.
  ADMITTED

  # Module instance has been dispatched to run on a cluster. This will run
  # the module instance until it is done or until it yields.
  DISPATCHED

  # Module instance is queued on the cluster. It will start running once the cluster's internal
  # queue launches it.
  QUEUED

  # Module instance is running and making progress on the cluster.
  RUNNING

  # Module has finished calculation, but result upload still pending.
  # We can dispatch more jobs, but cannot complete the module instance until the upload is complete.
  AWAITING_UPLOAD

  # Module instance has been run to completion.
  COMPLETED

  # Module instance failed to run.
  FAILED

  # Module instance was cancelled.
  CANCELLED
}

input ModuleInstanceStatusFilter {
  eq: ModuleInstanceStatus
  ne: ModuleInstanceStatus
}

enum ModuleInstanceTarget {
  TINY
  GADI
  BULLET
  BULLET_2
  BULLET_3
  BULLET_4
  SETONIX
  GADI_GPU
  BULLET_GPU
  BULLET_2_GPU
  BULLET_3_GPU
  BULLET_4_GPU
  SETONIX_GPU
  GADI_EXPRESS
  SETONIX_EXPRESS
}

input ModuleInstanceTargetFilter {
  eq: ModuleInstanceTarget
  ne: ModuleInstanceTarget
}

input ModuleSort {
  id: UuidSort
  path: StringSort
  metadata: MetadataSort
}

type MultipleSequenceAlignment {
  id: MultipleSequenceAlignmentId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  a_3m: TypedVirtualObject!
  protein: Protein!
}

type MultipleSequenceAlignmentConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [MultipleSequenceAlignmentEdge!]!

  # A list of nodes.
  nodes: [MultipleSequenceAlignment!]!
  total_count: Int!
}

# An edge in a connection.
type MultipleSequenceAlignmentEdge {
  # The item at the end of the edge
  node: MultipleSequenceAlignment!

  # A cursor for use in pagination
  cursor: String!
}

input MultipleSequenceAlignmentFilter {
  all: [MultipleSequenceAlignmentFilter!]
  any: [MultipleSequenceAlignmentFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
}

scalar MultipleSequenceAlignmentId

input MultipleSequenceAlignmentSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
}

type Mutation {
  login(username: String!, password: String!): User
  destroy(module: ModuleId!): Module!
  delete_argument(arg_id: ArgumentId!): ArgumentId!
  delete_module_instance(module: ModuleInstanceId!): ModuleInstance!
  delete_token(token_id: TokenId!): Token!
  tag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  untag(
    module: ModuleId
    module_instance: ModuleInstanceId
    argument: ArgumentId
    tags: [String!]!
  ): [String!]!
  run(instance: CreateModuleInstance!): ModuleInstance!

  # If a module instance fails due to environment issues (eg. inputs and module are valid),
  # this method can be used to retry the module instance.
  retry(
    instance: ModuleInstanceId!
    target: ModuleInstanceTarget
    resources: ResourcesInput
  ): ModuleInstance!
  upload_large_object(
    typeinfo: JSON!
    format: ObjectFormat!
    public: Boolean
  ): ObjectDescriptorWithUploadUrl!
  upload_object(
    file: Upload!
    typeinfo: JSON!
    format: ObjectFormat!
  ): ObjectDescriptor!

  # Cancel a currently running instance, but don't delete it
  cancel(instance: ModuleInstanceId!): ModuleInstanceId!

  # An (admin) endpoint to update all attributes of a module instance.
  # Only to be used in debug / rescue situations.
  update_module_instance(
    instance_id: ModuleInstanceId!
    instance_update: PatchModuleInstanceInput!
    arguments_update: [ArgumentInput!]
  ): ModuleInstance!

  # Track historical utilization
  track_module_instance_resource_utilization(
    utilization: CreateResourceUtilization!
  ): ResourceUtilization!
  create_argument(
    name: String
    typeinfo: JSON!
    tags: [String!]
    value: JSON!
  ): Argument!
  create_token: Token!
  deploy(module: CreateModule!): Module!
  eval(input: CreateRun!): Run!
  delete_run(run_id: RunId!): Run!
  update_account_config(
    account_id: AccountId!
    input: AccountConfigInput!
  ): AccountConfig!
  update_account_tier(account_id: AccountId!, tier: AccountTier!): AccountTier!
  fetch_protein_dossier(project_id: ProjectId!, protein_name: String!): Protein!
  create_binding_affinity(input: CreateBindingAffinity!): BindingAffinity!
  delete_binding_affinity(
    binding_affinity_id: BindingAffinityId!
  ): BindingAffinity!
  patch_binding_affinity(
    binding_affinity_id: BindingAffinityId!
    input: PatchBindingAffinity!
  ): BindingAffinity!
  create_binding_site_conformer(
    input: CreateBindingSiteConformer!
  ): BindingSiteConformer!
  delete_binding_site_conformer(
    binding_site_conformer_id: BindingSiteConformerId!
  ): BindingSiteConformer!
  patch_binding_site_conformer(
    binding_site_conformer_id: BindingSiteConformerId!
    input: PatchBindingSiteConformer!
  ): BindingSiteConformer!
  create_binding_site_conformer_prediction(
    input: CreateBindingSiteConformerPrediction!
  ): BindingSiteConformerPrediction!
  delete_binding_site_conformer_prediction(
    binding_site_conformer_prediction_id: BindingSiteConformerPredictionId!
  ): BindingSiteConformerPrediction!
  patch_binding_site_conformer_prediction(
    binding_site_conformer_prediction_id: BindingSiteConformerPredictionId!
    input: PatchBindingSiteConformerPrediction!
  ): BindingSiteConformerPrediction!
  create_binding_site_interactions(
    input: CreateBindingSiteInteractions!
  ): BindingSiteInteractions!
  delete_binding_site_interactions(
    binding_site_interactions_id: BindingSiteInteractionsId!
  ): BindingSiteInteractions!
  patch_binding_site_interactions(
    binding_site_interactions_id: BindingSiteInteractionsId!
    input: PatchBindingSiteInteractions!
  ): BindingSiteInteractions!
  create_binding_pose_affinity(
    input: CreateBindingPoseAffinity!
  ): BindingPoseAffinity!
  delete_binding_pose_affinity(
    binding_pose_affinity_id: BindingPoseAffinityId!
  ): BindingPoseAffinity!
  patch_binding_pose_affinity(
    binding_pose_affinity_id: BindingPoseAffinityId!
    input: PatchBindingPoseAffinity!
  ): BindingPoseAffinity!
  create_binding_pose_conformer(
    input: CreateBindingPoseConformer!
  ): BindingPoseConformer!
  delete_binding_pose_conformer(
    binding_pose_conformer_id: BindingPoseConformerId!
  ): BindingPoseConformer!
  patch_binding_pose_conformer(
    binding_pose_conformer_id: BindingPoseConformerId!
    input: PatchBindingPoseConformer!
  ): BindingPoseConformer!
  create_binding_pose_conformer_interactions(
    input: CreateBindingPoseConformerInteractions!
  ): BindingPoseConformerInteractions!
  delete_binding_pose_conformer_interactions(
    binding_pose_conformer_interactions_id: BindingPoseConformerInteractionsId!
  ): BindingPoseConformerInteractions!
  patch_binding_pose_conformer_interactions(
    binding_pose_conformer_interactions_id: BindingPoseConformerInteractionsId!
    input: PatchBindingPoseConformerInteractions!
  ): BindingPoseConformerInteractions!
  create_msa(
    input: CreateMultipleSequenceAlignment!
  ): MultipleSequenceAlignment!
  delete_msa(
    multiple_sequence_alignment_id: MultipleSequenceAlignmentId!
  ): MultipleSequenceAlignment!
  patch_msa(
    multiple_sequence_alignment_id: MultipleSequenceAlignmentId!
    input: PatchMultipleSequenceAlignment!
  ): MultipleSequenceAlignment!
  create_project(input: CreateProject!): Project!
  delete_project(project_id: ProjectId!): Project!
  patch_project(project_id: ProjectId!, input: PatchProject!): Project!
  create_protein(input: CreateProtein!): Protein!
  delete_protein(protein_id: ProteinId!): Protein!
  patch_protein(protein_id: ProteinId!, input: PatchProtein!): Protein!
  create_protein_conformer(input: CreateProteinConformer!): ProteinConformer!
  delete_protein_conformer(
    protein_conformer_id: ProteinConformerId!
  ): ProteinConformer!
  patch_protein_conformer(
    protein_conformer_id: ProteinConformerId!
    input: PatchProteinConformer!
  ): ProteinConformer!
  create_smol_conformer(input: CreateSmolConformer!): SmolConformer!
  delete_smol_conformer(smol_conformer_id: SmolConformerId!): SmolConformer!
  patch_smol_conformer(
    smol_conformer_id: SmolConformerId!
    input: PatchSmolConformer!
  ): SmolConformer!
  create_smol_library(input: CreateSmolLibrary!): SmolLibrary!
  delete_smol_library(smol_library_id: SmolLibraryId!): SmolLibrary!
  patch_smol_library(
    smol_library_id: SmolLibraryId!
    input: PatchSmolLibrary!
  ): SmolLibrary!
  create_smol_library_partition(
    input: CreateSmolLibraryPartition!
  ): SmolLibraryPartition!
  delete_smol_library_partition(
    smol_library_partition_id: SmolLibraryPartitionId!
  ): SmolLibraryPartition!
  patch_smol_library_partition(
    smol_library_partition_id: SmolLibraryPartitionId!
    input: PatchSmolLibraryPartition!
  ): SmolLibraryPartition!
  create_smol(input: CreateSmol!): Smol!
  delete_smol(smol_id: SmolId!): Smol!
  patch_smol(smol_id: SmolId!, input: PatchSmol!): Smol!
  create_structure(input: CreateStructure!): Structure!
  delete_structure(structure_id: StructureId!): Structure!
  patch_structure(
    structure_id: StructureId!
    input: PatchStructure!
  ): Structure!
  create_tag(input: CreateTag!): Tag!
  delete_tag(tag_id: TagId!): Tag!
  patch_tag(tag_id: TagId!, input: PatchTag!): Tag!
}

type ObjectDescriptor {
  id: ObjectDescriptorId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  object: VirtualObject!
  type_info: Type!
  base_url: String!
  contents: JSON!
  url: String!
}

type ObjectDescriptorConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ObjectDescriptorEdge!]!

  # A list of nodes.
  nodes: [ObjectDescriptor!]!
  total_count: Int!
}

# An edge in a connection.
type ObjectDescriptorEdge {
  # The item at the end of the edge
  node: ObjectDescriptor!

  # A cursor for use in pagination
  cursor: String!
}

input ObjectDescriptorFilter {
  all: [ObjectDescriptorFilter!]
  any: [ObjectDescriptorFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  object: VirtualObjectFilter
  base_url: StringFilter
  account_id: UuidFilter
}

scalar ObjectDescriptorId

input ObjectDescriptorSort {
  id: UuidSort
  metadata: MetadataSort
  object: VirtualObjectSort
  base_url: StringSort
}

type ObjectDescriptorWithUploadUrl {
  descriptor: ObjectDescriptor!
  upload_url: String!
}

enum ObjectFormat {
  json
  bin
}

input ObjectFormatFilter {
  eq: ObjectFormat
  ne: ObjectFormat
}

enum OrderBy {
  ASC
  DESC
}

# Information about pagination in a connection
type PageInfo {
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

input PatchBindingAffinity {
  name: String
  description: String
  tags: [String!]
  affinity: Float
  affinity_metric: String
}

input PatchBindingPoseAffinity {
  name: String
  description: String
  tags: [String!]
}

input PatchBindingPoseConformer {
  name: String
  description: String
  tags: [String!]
}

input PatchBindingPoseConformerInteractions {
  name: String
  description: String
  tags: [String!]
}

input PatchBindingSiteConformer {
  name: String
  description: String
  tags: [String!]
  bounding_box: BindingSiteBoundingBoxInput
  surface_atoms: [Int!]
}

input PatchBindingSiteConformerPrediction {
  name: String
  description: String
  tags: [String!]
  score: Float
  probability: Float
}

input PatchBindingSiteInteractions {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
  interactions: [BindingSiteInteractionInput!]
}

input PatchModuleInstanceInput {
  path: String
  args: [ArgumentInput!]
  target: ModuleInstanceTarget
  resources: ResourcesInput
  status: ModuleInstanceStatus
  metadata: CreateMetadata
  out_tags: [[String!]]
}

input PatchMultipleSequenceAlignment {
  name: String
  description: String
  tags: [String!]
  a_3m: TypedVirtualObject
}

input PatchProject {
  name: String
  description: String
  tags: [String!]
}

input PatchProtein {
  name: String
  description: String
  tags: [String!]
  sequence: String
}

input PatchProteinConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
}

input PatchSmol {
  name: String
  description: String
  tags: [String!]
  smi: String
  inchi: String
  data_blocks: [[String!]!]
}

input PatchSmolConformer {
  name: String
  description: String
  tags: [String!]
  residues: [Int!]
}

input PatchSmolLibrary {
  name: String
  description: String
  tags: [String!]
}

input PatchSmolLibraryPartition {
  name: String
  description: String
  tags: [String!]
  part_idx: Int
  part_size: Int
  structures: TypedVirtualObject
  smiles: TypedVirtualObject
  data_blocks: TypedVirtualObject
}

input PatchStructure {
  name: String
  description: String
  tags: [String!]
  rcsb_id: String
  topology: TypedVirtualObject
  residues: TypedVirtualObject
  chains: TypedVirtualObject
}

input PatchTag {
  name: String
  description: String
  tags: [String!]
  key: String
  value: String
  tagged_id: UUID
  tagged_type: TaggedType
}

enum PiStackKind {
  UNKNOWN
  P
  T
}

type ProgressEvent {
  n: Int!
  n_expected: Int!
  n_max: Int!
  done: Boolean!
}

type Project {
  id: ProjectId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  binding_affinity(id: BindingAffinityId!): BindingAffinity!
  binding_pose_affinity(id: BindingPoseAffinityId!): BindingPoseAffinity!
  binding_pose_conformer(id: BindingPoseConformerId!): BindingPoseConformer!
  binding_pose_conformer_interaction(
    id: BindingPoseConformerInteractionsId!
  ): BindingPoseConformerInteractions!
  binding_site_conformer(id: BindingSiteConformerId!): BindingSiteConformer!
  binding_site_conformer_prediction(
    id: BindingSiteConformerPredictionId!
  ): BindingSiteConformerPrediction!
  binding_site_interaction(
    id: BindingSiteInteractionsId!
  ): BindingSiteInteractions!
  msa(id: MultipleSequenceAlignmentId!): MultipleSequenceAlignment!
  protein(id: ProteinId!): Protein!
  protein_conformer(id: ProteinConformerId!): ProteinConformer!
  run(id: RunId!): Run!
  smol(id: SmolId!): Smol!
  smol_conformer(id: SmolConformerId!): SmolConformer!
  structure(id: StructureId!): Structure!
  binding_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingAffinityFilter
    sort: BindingAffinitySort
  ): BindingAffinityConnection!
  binding_pose_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseAffinityFilter
    sort: BindingPoseAffinitySort
  ): BindingPoseAffinityConnection!
  binding_pose_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerFilter
    sort: BindingPoseConformerSort
  ): BindingPoseConformerConnection!
  binding_pose_conformer_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerInteractionsFilter
    sort: BindingPoseConformerInteractionsSort
  ): BindingPoseConformerInteractionsConnection!
  binding_site_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteConformerFilter
    sort: BindingSiteConformerSort
  ): BindingSiteConformerConnection!
  binding_site_conformer_predictions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteConformerPredictionFilter
    sort: BindingSiteConformerPredictionSort
  ): BindingSiteConformerPredictionConnection!
  binding_site_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteInteractionsFilter
    sort: BindingSiteInteractionsSort
  ): BindingSiteInteractionsConnection!
  msas(
    after: String
    before: String
    first: Int
    last: Int
    filter: MultipleSequenceAlignmentFilter
    sort: MultipleSequenceAlignmentSort
  ): MultipleSequenceAlignmentConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilter
    sort: ProteinSort
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort: ProteinConformerSort
  ): ProteinConformerConnection!
  runs(
    after: String
    before: String
    first: Int
    last: Int
    filter: RunFilter
    sort: RunSort
  ): RunConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilter
    sort: SmolSort
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort: SmolConformerSort
  ): SmolConformerConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilter
    sort: StructureSort
  ): StructureConnection!
}

type ProjectConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProjectEdge!]!

  # A list of nodes.
  nodes: [Project!]!
  total_count: Int!
}

# An edge in a connection.
type ProjectEdge {
  # The item at the end of the edge
  node: Project!

  # A cursor for use in pagination
  cursor: String!
}

input ProjectFilter {
  all: [ProjectFilter!]
  any: [ProjectFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  account_id: UuidFilter
}

scalar ProjectId

input ProjectSort {
  id: UuidSort
  metadata: MetadataSort
  account_id: UuidSort
}

type Protein {
  id: ProteinId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  sequence: String!
  msas(
    after: String
    before: String
    first: Int
    last: Int
    filter: MultipleSequenceAlignmentFilter
    sort: MultipleSequenceAlignmentSort
  ): MultipleSequenceAlignmentConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort: ProteinConformerSort
  ): ProteinConformerConnection!
  binding_site_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteInteractionsFilter
    sort: BindingSiteInteractionsSort
  ): BindingSiteInteractionsConnection!
  binding_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingAffinityFilter
    sort: BindingAffinitySort
  ): BindingAffinityConnection!
}

type ProteinConformer {
  id: ProteinConformerId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  residues: [Int!]!
  protein: Protein!
  structure: Structure!
  binding_site_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteConformerFilter
    sort: BindingSiteConformerSort
  ): BindingSiteConformerConnection!
}

type ProteinConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinConformerEdge!]!

  # A list of nodes.
  nodes: [ProteinConformer!]!
  total_count: Int!
}

# An edge in a connection.
type ProteinConformerEdge {
  # The item at the end of the edge
  node: ProteinConformer!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinConformerFilter {
  all: [ProteinConformerFilter!]
  any: [ProteinConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  protein_id: UuidFilter
  structure_id: UuidFilter
}

scalar ProteinConformerId

input ProteinConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  protein_id: UuidSort
  structure_id: UuidSort
}

type ProteinConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [ProteinEdge!]!

  # A list of nodes.
  nodes: [Protein!]!
  total_count: Int!
}

# An edge in a connection.
type ProteinEdge {
  # The item at the end of the edge
  node: Protein!

  # A cursor for use in pagination
  cursor: String!
}

input ProteinFilter {
  all: [ProteinFilter!]
  any: [ProteinFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  sequence: StringFilter
}

scalar ProteinId

input ProteinSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  sequence: StringSort
}

type Query {
  modules(
    after: String
    before: String
    first: Int
    last: Int
    sort: ModuleSort
    filter: ModuleFilter
  ): ModuleConnection!
  latest_modules(
    after: String
    before: String
    first: Int
    last: Int
    names: [String!]
    targets: [ModuleInstanceTarget!]
  ): ModuleConnection!
  me: User!
  smol_libraries(
    after: String
    before: String
    first: Int
    last: Int
    sort: SmolLibrarySort
  ): SmolLibraryConnection!
  module(id: ModuleId!): Module!
  tiered_module_instances: [ModuleInstance!]!
  module_instance(id: ModuleInstanceId!): ModuleInstance!
  argument(id: ArgumentId!): Argument!
  object(id: ObjectDescriptorId!): ObjectDescriptor!
  object_path(path: UUID!): ObjectDescriptor!
}

scalar ResidueRef

# Validation and hints to resources to use for an instance.
type ResourceBounds {
  # number of gpus in node, None means no gpu required.
  gpu_min: Int

  # max number of gpus in node that can used, 0 means no gpu support.
  gpu_max: Int

  # optimal number of gpus in node
  gpu_hint: Int

  # minimum gpu memory required in MB per gpu
  gpu_mem_min: Int

  # maxmimum memory that can be used in MB (None means no limit)
  gpu_mem_max: Int

  # optimal gpu memory in MB
  gpu_mem_hint: Int

  # minimum number of cpus required, should be > 0 if Some
  cpu_min: Int

  # maximum number of cpus that can be used, 0 means no limit
  cpu_max: Int

  # optimal number of cpus
  cpu_hint: Int

  # minimum node count
  node_min: Int

  # maximum node count (e.g. maximum node parallelism)
  node_max: Int

  # most optimal node count
  node_hint: Int
  mem_min: Int
  mem_max: Int

  # in MB
  storage_min: Int

  # in MB (0 means no limit)
  storage_max: Int
}

type ResourceUtilization {
  id: ResourceUtilizationId!
  module_instance_id: ModuleInstanceId!
  target: ModuleInstanceTarget!
  gpu: Float
  mem: Float
  storage: Float!
  walltime: Float!
  cputime: Float!
  inodes: Float!
  sus: Int
  account_id: AccountId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
}

scalar ResourceUtilizationId

type ResourceUtilizationReport {
  target: ModuleInstanceTarget!
  from: DateTime!
  to: DateTime!
  gpu_avg: Float
  mem_avg: Float
  storage_total: Float!
  storage_avg: Float!
  walltime_total: Float!
  walltime_avg: Float!
  cputime_total: Float!
  cputime_avg: Float!
  inodes_total: Float!
  sus_total: Int
}

# Explicit resources required for an instance.
# Will fall back to the hint value if not specified.
type Resources {
  gpus: Int
  cpus: Int
  nodes: Int

  # RAM allocation
  mem: Int

  # Defaults to MB
  mem_units: MemUnits
  gpu_mem: Int
  gpu_mem_units: MemUnits

  # space to be allocated on the target, must be > the size of Object inputs
  storage: Int

  # Defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int

  # additional storage directories on target to mount
  storage_mounts: [String!]
}

# Explicit resources required for an instance.
# Will fall back to the hint value if not specified.
input ResourcesInput {
  gpus: Int
  cpus: Int
  nodes: Int

  # RAM allocation
  mem: Int

  # Defaults to MB
  mem_units: MemUnits
  gpu_mem: Int
  gpu_mem_units: MemUnits

  # space to be allocated on the target, must be > the size of Object inputs
  storage: Int

  # Defaults to B
  storage_units: MemUnits

  # walltime request in minutes - job will be killed if it exceeds this number
  walltime: Int

  # additional storage directories on target to mount
  storage_mounts: [String!]
}

type Run {
  id: RunId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  rex: String!
  result: JSON
  trace: JSON
  module_lock: JSONObject!
  status: RunStatus!
  binding_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingAffinityFilter
    sort: BindingAffinitySort
  ): BindingAffinityConnection!
  binding_pose_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseAffinityFilter
    sort: BindingPoseAffinitySort
  ): BindingPoseAffinityConnection!
  binding_pose_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerFilter
    sort: BindingPoseConformerSort
  ): BindingPoseConformerConnection!
  binding_pose_conformer_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerInteractionsFilter
    sort: BindingPoseConformerInteractionsSort
  ): BindingPoseConformerInteractionsConnection!
  binding_site_interactions(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteInteractionsFilter
    sort: BindingSiteInteractionsSort
  ): BindingSiteInteractionsConnection!
  binding_site_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingSiteConformerFilter
    sort: BindingSiteConformerSort
  ): BindingSiteConformerConnection!
  msas(
    after: String
    before: String
    first: Int
    last: Int
    filter: MultipleSequenceAlignmentFilter
    sort: MultipleSequenceAlignmentSort
  ): MultipleSequenceAlignmentConnection!
  proteins(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinFilter
    sort: ProteinSort
  ): ProteinConnection!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort: ProteinConformerSort
  ): ProteinConformerConnection!
  smols(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolFilter
    sort: SmolSort
  ): SmolConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort: SmolConformerSort
  ): SmolConformerConnection!
  smol_libraries(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolLibraryFilter
    sort: SmolLibrarySort
  ): SmolLibraryConnection!
  structures(
    after: String
    before: String
    first: Int
    last: Int
    filter: StructureFilter
    sort: StructureSort
  ): StructureConnection!
}

type RunConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [RunEdge!]!

  # A list of nodes.
  nodes: [Run!]!
  total_count: Int!
}

# An edge in a connection.
type RunEdge {
  # The item at the end of the edge
  node: Run!

  # A cursor for use in pagination
  cursor: String!
}

input RunFilter {
  all: [RunFilter!]
  any: [RunFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  rex: StringFilter
  status: RunStatusFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar RunId

input RunSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

enum RunStatus {
  PENDING
  RUNNING
  DONE
  ERROR
}

input RunStatusFilter {
  eq: RunStatus
  ne: RunStatus
}

type Smol {
  id: SmolId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  smi: String
  inchi: String
  data_blocks: [[String!]!]
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort: SmolConformerSort
  ): SmolConformerConnection!
  binding_affinities(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingAffinityFilter
    sort: BindingAffinitySort
  ): BindingAffinityConnection!
}

type SmolConformer {
  id: SmolConformerId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  residues: [Int!]!
  smol: Smol!
  structure: Structure!
  binding_pose_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: BindingPoseConformerFilter
    sort: BindingPoseConformerSort
  ): BindingPoseConformerConnection!
}

type SmolConformerConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolConformerEdge!]!

  # A list of nodes.
  nodes: [SmolConformer!]!
  total_count: Int!
}

# An edge in a connection.
type SmolConformerEdge {
  # The item at the end of the edge
  node: SmolConformer!

  # A cursor for use in pagination
  cursor: String!
}

input SmolConformerFilter {
  all: [SmolConformerFilter!]
  any: [SmolConformerFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smol_id: UuidFilter
  structure_id: UuidFilter
}

scalar SmolConformerId

input SmolConformerSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smol_id: UuidSort
  structure_id: UuidSort
}

type SmolConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolEdge!]!

  # A list of nodes.
  nodes: [Smol!]!
  total_count: Int!
}

# An edge in a connection.
type SmolEdge {
  # The item at the end of the edge
  node: Smol!

  # A cursor for use in pagination
  cursor: String!
}

input SmolFilter {
  all: [SmolFilter!]
  any: [SmolFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  smi: StringFilter
  inchi: StringFilter
}

scalar SmolId

type SmolLibrary {
  id: SmolLibraryId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  partitions(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolLibraryPartitionFilter
    sort: SmolLibraryPartitionSort
  ): SmolLibraryPartitionConnection!
  size_hint: Int!
}

type SmolLibraryConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolLibraryEdge!]!

  # A list of nodes.
  nodes: [SmolLibrary!]!
  total_count: Int!
}

# An edge in a connection.
type SmolLibraryEdge {
  # The item at the end of the edge
  node: SmolLibrary!

  # A cursor for use in pagination
  cursor: String!
}

input SmolLibraryFilter {
  all: [SmolLibraryFilter!]
  any: [SmolLibraryFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
}

scalar SmolLibraryId

type SmolLibraryPartition {
  id: SmolLibraryPartitionId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  part_idx: Int!
  part_size: Int!
  structures: TypedVirtualObject
  smiles: TypedVirtualObject!
  data_blocks: TypedVirtualObject!
  smol_library: SmolLibrary!
}

type SmolLibraryPartitionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [SmolLibraryPartitionEdge!]!

  # A list of nodes.
  nodes: [SmolLibraryPartition!]!
  total_count: Int!
}

# An edge in a connection.
type SmolLibraryPartitionEdge {
  # The item at the end of the edge
  node: SmolLibraryPartition!

  # A cursor for use in pagination
  cursor: String!
}

input SmolLibraryPartitionFilter {
  all: [SmolLibraryPartitionFilter!]
  any: [SmolLibraryPartitionFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  part_idx: I32Filter
  part_size: I32Filter
  smol_library_id: UuidFilter
}

scalar SmolLibraryPartitionId

input SmolLibraryPartitionSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  part_idx: I32Sort
  part_size: I32Sort
  smol_library_id: UuidSort
}

input SmolLibrarySort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
}

input SmolSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  smi: StringSort
  inchi: StringSort
}

input StringFilter {
  eq: String
  ne: String
  gt: String
  ge: String
  lt: String
  le: String
  like: String
  in: [String!]
}

enum StringSort {
  asc
  desc
}

type Structure {
  id: StructureId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  rcsb_id: String
  topology: TypedVirtualObject!
  residues: TypedVirtualObject!
  chains: TypedVirtualObject!
  protein_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: ProteinConformerFilter
    sort: ProteinConformerSort
  ): ProteinConformerConnection!
  smol_conformers(
    after: String
    before: String
    first: Int
    last: Int
    filter: SmolConformerFilter
    sort: SmolConformerSort
  ): SmolConformerConnection!
}

type StructureConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [StructureEdge!]!

  # A list of nodes.
  nodes: [Structure!]!
  total_count: Int!
}

# An edge in a connection.
type StructureEdge {
  # The item at the end of the edge
  node: Structure!

  # A cursor for use in pagination
  cursor: String!
}

input StructureFilter {
  all: [StructureFilter!]
  any: [StructureFilter!]
  id: UuidFilter
  metadata: MetadataFilter
  project_id: UuidFilter
  account_id: UuidFilter
  rcsb_id: StringFilter
}

scalar StructureId

input StructureSort {
  id: UuidSort
  metadata: MetadataSort
  project_id: UuidSort
  account_id: UuidSort
  rcsb_id: StringSort
}

type Subscription {
  stream(argumentId: ArgumentId!): JSON!
}

type Tag {
  id: TagId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  key: String!
  value: String
  tagged_id: UUID!
  tagged_type: TaggedType!
}

input TagFilter {
  in: [String!]
}

scalar TagId

enum TaggedType {
  structure
  protein
  protein_conformer
  smol
  smol_conformer
  run
  module
  module_instance
}

input TestCase {
  args: [ArgumentInput!]!
  target: ModuleInstanceTarget!
  resources: ResourcesInput
  tags: [String!]
}

type Token {
  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  id: TokenId!
}

type TokenConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TokenEdge!]!

  # A list of nodes.
  nodes: [Token!]!
  total_count: Int!
}

# An edge in a connection.
type TokenEdge {
  # The item at the end of the edge
  node: Token!

  # A cursor for use in pagination
  cursor: String!
}

input TokenFilter {
  all: [TokenFilter!]
  any: [TokenFilter!]
  metadata: MetadataFilter
  id: UuidFilter
  user_id: UuidFilter
}

scalar TokenId

input TokenSort {
  metadata: MetadataSort
  id: UuidSort
  user_id: UuidSort
}

scalar Type

scalar TypedVirtualObject

enum U64Sort {
  asc
  desc
}

# A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
# Strings within GraphQL. UUIDs are used to assign unique identifiers to
# entities without requiring a central allocating authority.
#
# # References
#
# * [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
# * [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
scalar UUID

scalar Upload

type User {
  id: UserId!

  # When the entity was created
  created_at: DateTime!

  # Last time the entity was updated
  updated_at: DateTime!

  # When the entity was deleted, is used to determine if a module is soft-deleted
  deleted_at: DateTime

  # User friendly name for the entity
  name: String

  # User friendly description for the entity
  description: String
  run_id: RunId

  # User defined tags for the entity
  tags: [String!]
  account: Account!
  tokens(
    after: String
    before: String
    first: Int
    last: Int
    filter: TokenFilter
    sort: TokenSort
  ): TokenConnection!
}

scalar UserId

input UuidFilter {
  is_null: Boolean
  eq: UUID
  ne: UUID
  in: [UUID!]
}

enum UuidSort {
  asc
  desc
}

type V1Tag {
  tag: String!
  metadata: Metadata!
  count: Int!
}

type V1TagConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [V1TagEdge!]!

  # A list of nodes.
  nodes: [V1Tag!]!
  total_count: Int!
}

# An edge in a connection.
type V1TagEdge {
  # The item at the end of the edge
  node: V1Tag!

  # A cursor for use in pagination
  cursor: String!
}

type VirtualObject {
  path: String!
  size: Int!
  format: ObjectFormat!
}

input VirtualObjectFilter {
  path: StringFilter
  size: I64Filter
  format: ObjectFormatFilter
}

input VirtualObjectSort {
  path: StringSort
  size: U64Sort
}

scalar Xyzf32
