# Generated by ariadne-codegen
# Source: combined.graphql

from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from .argument import Argument, ArgumentArgument
from .arguments import Arguments, ArgumentsMe
from .async_base_client import AsyncBaseClient
from .base_model import UNSET, UnsetType, Upload
from .cancel_module_instance import CancelModuleInstance
from .create_entity import CreateEntity, CreateEntityCreateEntity
from .create_experiment import CreateExperiment, CreateExperimentCreateExperiment
from .create_project import CreateProject, CreateProjectCreateProject
from .create_protein import CreateProtein, CreateProteinCreateProtein
from .create_protein_conformer import (
    CreateProteinConformer,
    CreateProteinConformerCreateProteinConformer,
)
from .create_smol import CreateSmol, CreateSmolCreateSmol
from .create_smol_conformer import (
    CreateSmolConformer,
    CreateSmolConformerCreateSmolConformer,
)
from .create_smol_tautomer import (
    CreateSmolTautomer,
    CreateSmolTautomerCreateSmolTautomer,
)
from .create_structure import CreateStructure, CreateStructureCreateStructure
from .delete_module_instance import (
    DeleteModuleInstance,
    DeleteModuleInstanceDeleteModuleInstance,
)
from .deploy import Deploy, DeployDeploy
from .entity import Entity, EntityEntity
from .enums import ModuleInstanceStatus, ModuleInstanceTarget, OrderBy
from .experiment import Experiment, ExperimentExperiment
from .input_types import (
    CreateExperimentInput,
    CreateProjectInput,
    CreateProteinConformerInput,
    CreateProteinInput,
    CreateSmolConformerInput,
    CreateSmolInput,
    CreateSmolTautomerInput,
    CreateStructureInput,
    ModuleInput,
    ModuleInstanceInput,
    ModuleInstanceResourcesInput,
    RawEntityInput,
    ResourceUtilizationInput,
    UpdateModuleInstanceInput,
)
from .latest_modules import LatestModules, LatestModulesLatestModules
from .module_instance_details import (
    ModuleInstanceDetails,
    ModuleInstanceDetailsModuleInstance,
)
from .module_instance_minimal import (
    ModuleInstanceMinimal,
    ModuleInstanceMinimalModuleInstance,
)
from .module_instances import ModuleInstances, ModuleInstancesMe
from .modules import Modules, ModulesModules
from .object import Object
from .project import Project, ProjectProject
from .protein import Protein, ProteinProtein
from .protein_conformer import ProteinConformer, ProteinConformerProteinConformer
from .retry import Retry, RetryRetry
from .run import Run, RunRun
from .smol import Smol, SmolSmol
from .smol_conformer import SmolConformer, SmolConformerSmolConformer
from .smol_tautomer import SmolTautomer, SmolTautomerSmolTautomer
from .structure import Structure, StructureStructure
from .tag import Tag
from .track_utilization import (
    TrackUtilization,
    TrackUtilizationTrackModuleInstanceResourceUtilization,
)
from .untag import Untag
from .update_module_instance import (
    UpdateModuleInstance,
    UpdateModuleInstanceUpdateModuleInstance,
)
from .upload_arg import UploadArg, UploadArgUploadArg


def gql(q: str) -> str:
    return q


class Client(AsyncBaseClient):
    async def cancel_module_instance(self, module_instance_id: UUID, **kwargs: Any) -> UUID:
        query = gql(
            """
            mutation cancel_module_instance($moduleInstanceId: ModuleInstanceId!) {
              cancel(instance: $moduleInstanceId)
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query, operation_name="cancel_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CancelModuleInstance.model_validate(data).cancel

    async def delete_module_instance(
        self, module_instance_id: UUID, **kwargs: Any
    ) -> DeleteModuleInstanceDeleteModuleInstance:
        query = gql(
            """
            mutation delete_module_instance($moduleInstanceId: ModuleInstanceId!) {
              delete_module_instance(module: $moduleInstanceId) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query, operation_name="delete_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return DeleteModuleInstance.model_validate(data).delete_module_instance

    async def deploy(self, module: ModuleInput, **kwargs: Any) -> DeployDeploy:
        query = gql(
            """
            mutation deploy($module: ModuleInput!) {
              deploy(module: $module) {
                id
                path
              }
            }
            """
        )
        variables: Dict[str, object] = {"module": module}
        response = await self.execute(query=query, operation_name="deploy", variables=variables, **kwargs)
        data = self.get_data(response)
        return Deploy.model_validate(data).deploy

    async def create_entity(self, entity: RawEntityInput, **kwargs: Any) -> CreateEntityCreateEntity:
        query = gql(
            """
            mutation create_entity($entity: RawEntityInput!) {
              create_entity(entity: $entity) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"entity": entity}
        response = await self.execute(
            query=query, operation_name="create_entity", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateEntity.model_validate(data).create_entity

    async def create_experiment(
        self, experiment: CreateExperimentInput, **kwargs: Any
    ) -> CreateExperimentCreateExperiment:
        query = gql(
            """
            mutation create_experiment($experiment: CreateExperimentInput!) {
              create_experiment(input: $experiment) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"experiment": experiment}
        response = await self.execute(
            query=query, operation_name="create_experiment", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateExperiment.model_validate(data).create_experiment

    async def create_project(self, project: CreateProjectInput, **kwargs: Any) -> CreateProjectCreateProject:
        query = gql(
            """
            mutation create_project($project: CreateProjectInput!) {
              create_project(input: $project) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"project": project}
        response = await self.execute(
            query=query, operation_name="create_project", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProject.model_validate(data).create_project

    async def create_protein(self, protein: CreateProteinInput, **kwargs: Any) -> CreateProteinCreateProtein:
        query = gql(
            """
            mutation create_protein($protein: CreateProteinInput!) {
              create_protein(input: $protein) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein": protein}
        response = await self.execute(
            query=query, operation_name="create_protein", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProtein.model_validate(data).create_protein

    async def create_protein_conformer(
        self, protein_conformer: CreateProteinConformerInput, **kwargs: Any
    ) -> CreateProteinConformerCreateProteinConformer:
        query = gql(
            """
            mutation create_protein_conformer($protein_conformer: CreateProteinConformerInput!) {
              create_protein_conformer(input: $protein_conformer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein_conformer": protein_conformer}
        response = await self.execute(
            query=query, operation_name="create_protein_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProteinConformer.model_validate(data).create_protein_conformer

    async def argument(self, id: UUID, **kwargs: Any) -> ArgumentArgument:
        query = gql(
            """
            query argument($id: ArgumentId!) {
              argument(id: $id) {
                ...ArgumentFull
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="argument", variables=variables, **kwargs)
        data = self.get_data(response)
        return Argument.model_validate(data).argument

    async def arguments(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        typeinfo: Union[Optional[List[Any]], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        resolved: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ArgumentsMe:
        query = gql(
            """
            query arguments($after: String, $before: String, $first: Int, $last: Int, $typeinfo: [Type!], $tags: [String!], $resolved: Boolean) {
              me {
                account {
                  arguments(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    typeinfo: $typeinfo
                    tags: $tags
                    resolved: $resolved
                  ) {
                    pageInfo {
                      ...PageInfoFull
                    }
                    edges {
                      cursor
                      node {
                        ...ArgumentFull
                      }
                    }
                  }
                }
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "typeinfo": typeinfo,
            "tags": tags,
            "resolved": resolved,
        }
        response = await self.execute(query=query, operation_name="arguments", variables=variables, **kwargs)
        data = self.get_data(response)
        return Arguments.model_validate(data).me

    async def latest_modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        order: Union[Optional[OrderBy], UnsetType] = UNSET,
        names: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> LatestModulesLatestModules:
        query = gql(
            """
            query latest_modules($after: String, $before: String, $first: Int, $last: Int, $order: OrderBy, $names: [String!]) {
              latest_modules(
                after: $after
                before: $before
                first: $first
                last: $last
                order: $order
                names: $names
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              usage
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "order": order,
            "names": names,
        }
        response = await self.execute(
            query=query, operation_name="latest_modules", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return LatestModules.model_validate(data).latest_modules

    async def modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        path: Union[Optional[str], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModulesModules:
        query = gql(
            """
            query modules($after: String, $before: String, $first: Int, $last: Int, $path: String, $tags: [String!]) {
              modules(
                first: $first
                last: $last
                after: $after
                before: $before
                path: $path
                tags: $tags
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              usage
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "path": path,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="modules", variables=variables, **kwargs)
        data = self.get_data(response)
        return Modules.model_validate(data).modules

    async def module_instance_details(
        self,
        id: UUID,
        stderr_after: Union[Optional[str], UnsetType] = UNSET,
        stderr_before: Union[Optional[str], UnsetType] = UNSET,
        stdout_after: Union[Optional[str], UnsetType] = UNSET,
        stdout_before: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstanceDetailsModuleInstance:
        query = gql(
            """
            query module_instance_details($id: ModuleInstanceId!, $stderr_after: String, $stderr_before: String, $stdout_after: String, $stdout_before: String) {
              module_instance(id: $id) {
                ...ModuleInstanceFull
                stdout(after: $stdout_after, before: $stdout_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
                stderr(after: $stderr_after, before: $stderr_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }

            fragment ModuleInstanceFull on ModuleInstance {
              ...ModuleInstanceCommon
              ins {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
              }
              outs {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
              }
              resources {
                gpus
                nodes
                mem
                storage
                walltime
              }
              progress {
                n
                n_expected
                n_max
                done
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "id": id,
            "stderr_after": stderr_after,
            "stderr_before": stderr_before,
            "stdout_after": stdout_after,
            "stdout_before": stdout_before,
        }
        response = await self.execute(
            query=query, operation_name="module_instance_details", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceDetails.model_validate(data).module_instance

    async def module_instances(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        path: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        status: Union[Optional[ModuleInstanceStatus], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        ids: Union[Optional[List[UUID]], UnsetType] = UNSET,
        in_argument_ids: Union[Optional[List[UUID]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstancesMe:
        query = gql(
            """
            query module_instances($after: String, $before: String, $first: Int, $last: Int, $path: String, $name: String, $status: ModuleInstanceStatus, $tags: [String!], $ids: [ModuleInstanceId!], $in_argument_ids: [ArgumentId!]) {
              me {
                account {
                  module_instances(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    path: $path
                    status: $status
                    name: $name
                    tags: $tags
                    ids: $ids
                    in_arguments: $in_argument_ids
                  ) {
                    edges {
                      cursor
                      node {
                        ...SimpleModuleInstanceFull
                      }
                    }
                    pageInfo {
                      ...PageInfoFull
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }

            fragment SimpleModuleInstanceCommon on SimpleModuleInstance {
              id
              account_id
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }

            fragment SimpleModuleInstanceFull on SimpleModuleInstance {
              ...SimpleModuleInstanceCommon
              ins {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
              }
              outs {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
              }
              resources {
                gpus
                nodes
                mem
                storage
                walltime
              }
              progress {
                n
                n_expected
                n_max
                done
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "path": path,
            "name": name,
            "status": status,
            "tags": tags,
            "ids": ids,
            "in_argument_ids": in_argument_ids,
        }
        response = await self.execute(
            query=query, operation_name="module_instances", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstances.model_validate(data).me

    async def module_instance_minimal(self, id: UUID, **kwargs: Any) -> ModuleInstanceMinimalModuleInstance:
        query = gql(
            """
            query module_instance_minimal($id: ModuleInstanceId!) {
              module_instance(id: $id) {
                ...ModuleInstanceCommon
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="module_instance_minimal", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceMinimal.model_validate(data).module_instance

    async def object(self, id: UUID, **kwargs: Any) -> Any:
        query = gql(
            """
            query object($id: ArgumentId!) {
              object(id: $id)
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="object", variables=variables, **kwargs)
        data = self.get_data(response)
        return Object.model_validate(data).object

    async def entity(self, id: Any, **kwargs: Any) -> Optional[EntityEntity]:
        query = gql(
            """
            query entity($id: UUID!) {
              entity(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="entity", variables=variables, **kwargs)
        data = self.get_data(response)
        return Entity.model_validate(data).entity

    async def project(self, id: Any, **kwargs: Any) -> Optional[ProjectProject]:
        query = gql(
            """
            query project($id: UUID!) {
              project(id: $id) {
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                }
                tags
                proteins {
                  edges {
                    node {
                      id
                    }
                  }
                }
                protein_conformers {
                  edges {
                    node {
                      id
                    }
                  }
                }
                smols {
                  edges {
                    node {
                      id
                    }
                  }
                }
                smol_conformers {
                  edges {
                    node {
                      id
                    }
                  }
                }
                smol_tautomers {
                  edges {
                    node {
                      id
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="project", variables=variables, **kwargs)
        data = self.get_data(response)
        return Project.model_validate(data).project

    async def protein(self, id: Any, **kwargs: Any) -> Optional[ProteinProtein]:
        query = gql(
            """
            query protein($id: UUID!) {
              protein(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                  sequence
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="protein", variables=variables, **kwargs)
        data = self.get_data(response)
        return Protein.model_validate(data).protein

    async def protein_conformer(self, id: Any, **kwargs: Any) -> Optional[ProteinConformerProteinConformer]:
        query = gql(
            """
            query protein_conformer($id: UUID!) {
              protein_conformer(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="protein_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ProteinConformer.model_validate(data).protein_conformer

    async def smol(self, id: Any, **kwargs: Any) -> Optional[SmolSmol]:
        query = gql(
            """
            query smol($id: UUID!) {
              smol(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                  inchi
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="smol", variables=variables, **kwargs)
        data = self.get_data(response)
        return Smol.model_validate(data).smol

    async def smol_conformer(self, id: Any, **kwargs: Any) -> Optional[SmolConformerSmolConformer]:
        query = gql(
            """
            query smol_conformer($id: UUID!) {
              smol_conformer(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="smol_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SmolConformer.model_validate(data).smol_conformer

    async def smol_tautomer(self, id: Any, **kwargs: Any) -> Optional[SmolTautomerSmolTautomer]:
        query = gql(
            """
            query smol_tautomer($id: UUID!) {
              smol_tautomer(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                  inchi
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="smol_tautomer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SmolTautomer.model_validate(data).smol_tautomer

    async def structure(self, id: Any, **kwargs: Any) -> Optional[StructureStructure]:
        query = gql(
            """
            query structure($id: UUID!) {
              structure(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                }
                topology {
                  symbols
                  geometry
                  connectivity
                  formal_charges
                  labels
                  partial_charges
                  fragments
                  fragment_formal_charges
                  fragment_partial_charges
                  velocities
                  alts
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="structure", variables=variables, **kwargs)
        data = self.get_data(response)
        return Structure.model_validate(data).structure

    async def experiment(self, id: Any, **kwargs: Any) -> Optional[ExperimentExperiment]:
        query = gql(
            """
            query experiment($id: UUID!) {
              experiment(id: $id) {
                id
                createdAt
                updatedAt
                deletedAt
                data {
                  name
                  unit
                  measure
                  value
                  assay
                }
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="experiment", variables=variables, **kwargs)
        data = self.get_data(response)
        return Experiment.model_validate(data).experiment

    async def retry(
        self,
        instance: UUID,
        target: ModuleInstanceTarget,
        resources: Union[Optional[ModuleInstanceResourcesInput], UnsetType] = UNSET,
        **kwargs: Any
    ) -> RetryRetry:
        query = gql(
            """
            mutation retry($instance: ModuleInstanceId!, $target: ModuleInstanceTarget!, $resources: ModuleInstanceResourcesInput) {
              retry(instance: $instance, target: $target, resources: $resources) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "instance": instance,
            "target": target,
            "resources": resources,
        }
        response = await self.execute(query=query, operation_name="retry", variables=variables, **kwargs)
        data = self.get_data(response)
        return Retry.model_validate(data).retry

    async def run(self, instance: ModuleInstanceInput, **kwargs: Any) -> RunRun:
        query = gql(
            """
            mutation run($instance: ModuleInstanceInput!) {
              run(instance: $instance) {
                id
                outs {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"instance": instance}
        response = await self.execute(query=query, operation_name="run", variables=variables, **kwargs)
        data = self.get_data(response)
        return Run.model_validate(data).run

    async def create_smol(self, smol: CreateSmolInput, **kwargs: Any) -> CreateSmolCreateSmol:
        query = gql(
            """
            mutation create_smol($smol: CreateSmolInput!) {
              create_smol(input: $smol) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol": smol}
        response = await self.execute(
            query=query, operation_name="create_smol", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmol.model_validate(data).create_smol

    async def create_smol_conformer(
        self, smol_conformer: CreateSmolConformerInput, **kwargs: Any
    ) -> CreateSmolConformerCreateSmolConformer:
        query = gql(
            """
            mutation create_smol_conformer($smol_conformer: CreateSmolConformerInput!) {
              create_smol_conformer(input: $smol_conformer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol_conformer": smol_conformer}
        response = await self.execute(
            query=query, operation_name="create_smol_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmolConformer.model_validate(data).create_smol_conformer

    async def create_smol_tautomer(
        self, smol_tautomer: CreateSmolTautomerInput, **kwargs: Any
    ) -> CreateSmolTautomerCreateSmolTautomer:
        query = gql(
            """
            mutation create_smol_tautomer($smol_tautomer: CreateSmolTautomerInput!) {
              create_smol_tautomer(input: $smol_tautomer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol_tautomer": smol_tautomer}
        response = await self.execute(
            query=query, operation_name="create_smol_tautomer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmolTautomer.model_validate(data).create_smol_tautomer

    async def create_structure(
        self, structure: CreateStructureInput, **kwargs: Any
    ) -> CreateStructureCreateStructure:
        query = gql(
            """
            mutation create_structure($structure: CreateStructureInput!) {
              create_structure(input: $structure) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"structure": structure}
        response = await self.execute(
            query=query, operation_name="create_structure", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateStructure.model_validate(data).create_structure

    async def tag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation tag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              tag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="tag", variables=variables, **kwargs)
        data = self.get_data(response)
        return Tag.model_validate(data).tag

    async def track_utilization(
        self, utilization: ResourceUtilizationInput, **kwargs: Any
    ) -> TrackUtilizationTrackModuleInstanceResourceUtilization:
        query = gql(
            """
            mutation track_utilization($utilization: ResourceUtilizationInput!) {
              track_module_instance_resource_utilization(utilization: $utilization) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"utilization": utilization}
        response = await self.execute(
            query=query, operation_name="track_utilization", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return TrackUtilization.model_validate(data).track_module_instance_resource_utilization

    async def untag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation untag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              untag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="untag", variables=variables, **kwargs)
        data = self.get_data(response)
        return Untag.model_validate(data).untag

    async def update_module_instance(
        self, module_instance_update: UpdateModuleInstanceInput, **kwargs: Any
    ) -> UpdateModuleInstanceUpdateModuleInstance:
        query = gql(
            """
            mutation update_module_instance($moduleInstanceUpdate: UpdateModuleInstanceInput!) {
              update_module_instance(instance_update: $moduleInstanceUpdate) {
                id
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceUpdate": module_instance_update}
        response = await self.execute(
            query=query, operation_name="update_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UpdateModuleInstance.model_validate(data).update_module_instance

    async def upload_arg(self, typeinfo: Any, file: Upload, **kwargs: Any) -> UploadArgUploadArg:
        query = gql(
            """
            mutation upload_arg($typeinfo: JSON!, $file: Upload!) {
              upload_arg(typeinfo: $typeinfo, file: $file) {
                id
                value
              }
            }
            """
        )
        variables: Dict[str, object] = {"typeinfo": typeinfo, "file": file}
        response = await self.execute(query=query, operation_name="upload_arg", variables=variables, **kwargs)
        data = self.get_data(response)
        return UploadArg.model_validate(data).upload_arg
