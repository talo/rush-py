# Generated by ariadne-codegen
# Source: combined.graphql

from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from .argument import Argument, ArgumentArgument
from .arguments import Arguments, ArgumentsMe
from .async_base_client import AsyncBaseClient
from .base_model import UNSET, UnsetType
from .binding_affinities import BindingAffinities, BindingAffinitiesMe
from .binding_affinity import BindingAffinity, BindingAffinityMe
from .binding_pose_conformer import BindingPoseConformer, BindingPoseConformerMe
from .binding_pose_conformer_interaction import (
    BindingPoseConformerInteraction,
    BindingPoseConformerInteractionMe,
)
from .binding_pose_conformer_interactions import (
    BindingPoseConformerInteractions,
    BindingPoseConformerInteractionsMe,
)
from .binding_pose_conformers import BindingPoseConformers, BindingPoseConformersMe
from .binding_site_conformer import BindingSiteConformer, BindingSiteConformerMe
from .binding_site_conformers import BindingSiteConformers, BindingSiteConformersMe
from .binding_site_interaction import BindingSiteInteraction, BindingSiteInteractionMe
from .binding_site_interactions import (
    BindingSiteInteractions,
    BindingSiteInteractionsMe,
)
from .cancel_module_instance import CancelModuleInstance
from .create_binding_affinity import (
    CreateBindingAffinity,
    CreateBindingAffinityCreateBindingAffinity,
)
from .create_binding_pose_affinity import (
    CreateBindingPoseAffinity,
    CreateBindingPoseAffinityCreateBindingPoseAffinity,
)
from .create_binding_pose_conformer import (
    CreateBindingPoseConformer,
    CreateBindingPoseConformerCreateBindingPoseConformer,
)
from .create_binding_pose_conformer_interactions import (
    CreateBindingPoseConformerInteractions,
    CreateBindingPoseConformerInteractionsCreateBindingPoseConformerInteractions,
)
from .create_binding_site_conformer import (
    CreateBindingSiteConformer,
    CreateBindingSiteConformerCreateBindingSiteConformer,
)
from .create_binding_site_conformer_prediction import (
    CreateBindingSiteConformerPrediction,
    CreateBindingSiteConformerPredictionCreateBindingSiteConformerPrediction,
)
from .create_binding_site_interactions import (
    CreateBindingSiteInteractions,
    CreateBindingSiteInteractionsCreateBindingSiteInteractions,
)
from .create_multiple_sequence_alignment import (
    CreateMultipleSequenceAlignment,
    CreateMultipleSequenceAlignmentCreateMsa,
)
from .create_project import CreateProject, CreateProjectCreateProject
from .create_protein import CreateProtein, CreateProteinCreateProtein
from .create_protein_conformer import (
    CreateProteinConformer,
    CreateProteinConformerCreateProteinConformer,
)
from .create_smol import CreateSmol, CreateSmolCreateSmol
from .create_smol_conformer import (
    CreateSmolConformer,
    CreateSmolConformerCreateSmolConformer,
)
from .create_smol_library import CreateSmolLibrary, CreateSmolLibraryCreateSmolLibrary
from .create_smol_library_partition import (
    CreateSmolLibraryPartition,
    CreateSmolLibraryPartitionCreateSmolLibraryPartition,
)
from .create_structure import CreateStructure, CreateStructureCreateStructure
from .create_tag import CreateTag, CreateTagCreateTag
from .delete_module_instance import (
    DeleteModuleInstance,
    DeleteModuleInstanceDeleteModuleInstance,
)
from .deploy import Deploy, DeployDeploy
from .enums import AccountTier, ModuleInstanceTarget, ObjectFormat
from .input_types import (
    AccountConfigInput,
    ArgumentFilter,
    ArgumentInput,
    CreateBindingAffinity,
    CreateBindingPoseAffinity,
    CreateBindingPoseConformer,
    CreateBindingPoseConformerInteractions,
    CreateBindingSiteConformer,
    CreateBindingSiteConformerPrediction,
    CreateBindingSiteInteractions,
    CreateModule,
    CreateModuleInstance,
    CreateMultipleSequenceAlignment,
    CreateProject,
    CreateProtein,
    CreateProteinConformer,
    CreateResourceUtilization,
    CreateSmol,
    CreateSmolConformer,
    CreateSmolLibrary,
    CreateSmolLibraryPartition,
    CreateStructure,
    CreateTag,
    ModuleFilter,
    ModuleInstanceFilter,
    ModuleInstanceSort,
    PatchModuleInstanceInput,
    ResourcesInput,
    SmolLibrarySort,
)
from .latest_modules import LatestModules, LatestModulesLatestModules
from .module_instance_details import (
    ModuleInstanceDetails,
    ModuleInstanceDetailsModuleInstance,
)
from .module_instance_minimal import (
    ModuleInstanceMinimal,
    ModuleInstanceMinimalModuleInstance,
)
from .module_instances import ModuleInstances, ModuleInstancesMe
from .modules import Modules, ModulesModules
from .msa import Msa, MsaMe
from .msas import Msas, MsasMe
from .object_contents import ObjectContents, ObjectContentsObjectPath
from .object_url import ObjectUrl, ObjectUrlObjectPath
from .project import Project, ProjectMe
from .projects import Projects, ProjectsMe
from .protein import Protein, ProteinMe
from .protein_conformer import ProteinConformer, ProteinConformerMe
from .protein_conformers import ProteinConformers, ProteinConformersMe
from .proteins import Proteins, ProteinsMe
from .retry import Retry, RetryRetry
from .run import Run, RunMe
from .run_module import RunModule, RunModuleRun
from .runs import Runs, RunsMe
from .smol import Smol, SmolMe
from .smol_conformer import SmolConformer, SmolConformerMe
from .smol_conformers import SmolConformers, SmolConformersMe
from .smol_libraries import SmolLibraries, SmolLibrariesSmolLibraries
from .smols import Smols, SmolsMe
from .structure import Structure, StructureMe
from .structures import Structures, StructuresMe
from .tag import Tag
from .track_utilization import (
    TrackUtilization,
    TrackUtilizationTrackModuleInstanceResourceUtilization,
)
from .untag import Untag
from .update_account_config import (
    UpdateAccountConfig,
    UpdateAccountConfigUpdateAccountConfig,
)
from .update_account_tier import UpdateAccountTier
from .update_module_instance import (
    UpdateModuleInstance,
    UpdateModuleInstanceUpdateModuleInstance,
)
from .upload_large_object import UploadLargeObject, UploadLargeObjectUploadLargeObject


def gql(q: str) -> str:
    return q


class Client(AsyncBaseClient):
    async def create_binding_affinity(
        self, binding_affinity: CreateBindingAffinity, **kwargs: Any
    ) -> CreateBindingAffinityCreateBindingAffinity:
        query = gql(
            """
            mutation create_binding_affinity($binding_affinity: CreateBindingAffinity!) {
              create_binding_affinity(input: $binding_affinity) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"binding_affinity": binding_affinity}
        response = await self.execute(
            query=query,
            operation_name="create_binding_affinity",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingAffinity.model_validate(data).create_binding_affinity

    async def create_binding_pose_affinity(
        self, binding_pose_affinity: CreateBindingPoseAffinity, **kwargs: Any
    ) -> CreateBindingPoseAffinityCreateBindingPoseAffinity:
        query = gql(
            """
            mutation create_binding_pose_affinity($binding_pose_affinity: CreateBindingPoseAffinity!) {
              create_binding_pose_affinity(input: $binding_pose_affinity) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"binding_pose_affinity": binding_pose_affinity}
        response = await self.execute(
            query=query,
            operation_name="create_binding_pose_affinity",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingPoseAffinity.model_validate(
            data
        ).create_binding_pose_affinity

    async def create_binding_pose_conformer(
        self, binding_pose_conformer: CreateBindingPoseConformer, **kwargs: Any
    ) -> CreateBindingPoseConformerCreateBindingPoseConformer:
        query = gql(
            """
            mutation create_binding_pose_conformer($binding_pose_conformer: CreateBindingPoseConformer!) {
              create_binding_pose_conformer(input: $binding_pose_conformer) {
                id
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "binding_pose_conformer": binding_pose_conformer
        }
        response = await self.execute(
            query=query,
            operation_name="create_binding_pose_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingPoseConformer.model_validate(
            data
        ).create_binding_pose_conformer

    async def create_binding_pose_conformer_interactions(
        self,
        binding_pose_conformer_interactions: CreateBindingPoseConformerInteractions,
        **kwargs: Any
    ) -> CreateBindingPoseConformerInteractionsCreateBindingPoseConformerInteractions:
        query = gql(
            """
            mutation create_binding_pose_conformer_interactions($binding_pose_conformer_interactions: CreateBindingPoseConformerInteractions!) {
              create_binding_pose_conformer_interactions(
                input: $binding_pose_conformer_interactions
              ) {
                id
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "binding_pose_conformer_interactions": binding_pose_conformer_interactions
        }
        response = await self.execute(
            query=query,
            operation_name="create_binding_pose_conformer_interactions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingPoseConformerInteractions.model_validate(
            data
        ).create_binding_pose_conformer_interactions

    async def create_binding_site_conformer(
        self, binding_site_conformer: CreateBindingSiteConformer, **kwargs: Any
    ) -> CreateBindingSiteConformerCreateBindingSiteConformer:
        query = gql(
            """
            mutation create_binding_site_conformer($binding_site_conformer: CreateBindingSiteConformer!) {
              create_binding_site_conformer(input: $binding_site_conformer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "binding_site_conformer": binding_site_conformer
        }
        response = await self.execute(
            query=query,
            operation_name="create_binding_site_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingSiteConformer.model_validate(
            data
        ).create_binding_site_conformer

    async def create_binding_site_conformer_prediction(
        self,
        binding_site_conformer_prediction: CreateBindingSiteConformerPrediction,
        **kwargs: Any
    ) -> CreateBindingSiteConformerPredictionCreateBindingSiteConformerPrediction:
        query = gql(
            """
            mutation create_binding_site_conformer_prediction($binding_site_conformer_prediction: CreateBindingSiteConformerPrediction!) {
              create_binding_site_conformer_prediction(
                input: $binding_site_conformer_prediction
              ) {
                id
                score
                probability
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "binding_site_conformer_prediction": binding_site_conformer_prediction
        }
        response = await self.execute(
            query=query,
            operation_name="create_binding_site_conformer_prediction",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingSiteConformerPrediction.model_validate(
            data
        ).create_binding_site_conformer_prediction

    async def create_binding_site_interactions(
        self, binding_site_interactions: CreateBindingSiteInteractions, **kwargs: Any
    ) -> CreateBindingSiteInteractionsCreateBindingSiteInteractions:
        query = gql(
            """
            mutation create_binding_site_interactions($binding_site_interactions: CreateBindingSiteInteractions!) {
              create_binding_site_interactions(input: $binding_site_interactions) {
                id
                residues
                interactions {
                  kind
                }
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "binding_site_interactions": binding_site_interactions
        }
        response = await self.execute(
            query=query,
            operation_name="create_binding_site_interactions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateBindingSiteInteractions.model_validate(
            data
        ).create_binding_site_interactions

    async def cancel_module_instance(
        self, module_instance_id: UUID, **kwargs: Any
    ) -> UUID:
        query = gql(
            """
            mutation cancel_module_instance($moduleInstanceId: ModuleInstanceId!) {
              cancel(instance: $moduleInstanceId)
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query,
            operation_name="cancel_module_instance",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CancelModuleInstance.model_validate(data).cancel

    async def create_project(
        self, project: CreateProject, **kwargs: Any
    ) -> CreateProjectCreateProject:
        query = gql(
            """
            mutation create_project($project: CreateProject!) {
              create_project(input: $project) {
                id
                name
                description
              }
            }
            """
        )
        variables: Dict[str, object] = {"project": project}
        response = await self.execute(
            query=query, operation_name="create_project", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProject.model_validate(data).create_project

    async def delete_module_instance(
        self, module_instance_id: UUID, **kwargs: Any
    ) -> DeleteModuleInstanceDeleteModuleInstance:
        query = gql(
            """
            mutation delete_module_instance($moduleInstanceId: ModuleInstanceId!) {
              delete_module_instance(module: $moduleInstanceId) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query,
            operation_name="delete_module_instance",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteModuleInstance.model_validate(data).delete_module_instance

    async def deploy(self, module: CreateModule, **kwargs: Any) -> DeployDeploy:
        query = gql(
            """
            mutation deploy($module: CreateModule!) {
              deploy(module: $module) {
                id
                path
              }
            }
            """
        )
        variables: Dict[str, object] = {"module": module}
        response = await self.execute(
            query=query, operation_name="deploy", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Deploy.model_validate(data).deploy

    async def module_instances(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        sort: Union[Optional[ModuleInstanceSort], UnsetType] = UNSET,
        filter: Union[Optional[ModuleInstanceFilter], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstancesMe:
        query = gql(
            """
            query module_instances($after: String, $before: String, $first: Int, $last: Int, $sort: ModuleInstanceSort, $filter: ModuleInstanceFilter) {
              me {
                account {
                  module_instances(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    sort: $sort
                    filter: $filter
                  ) {
                    edges {
                      cursor
                      node {
                        id
                        account_id
                        created_at
                        deleted_at
                        queued_at
                        admitted_at
                        dispatched_at
                        completed_at
                        path
                        status
                        target
                        tags
                        ins {
                          id
                          created_at
                          deleted_at
                          rejected_at
                          account_id
                          typeinfo
                          value
                          tags
                          source
                        }
                        outs {
                          id
                          created_at
                          deleted_at
                          rejected_at
                          account_id
                          typeinfo
                          value
                          tags
                          source
                        }
                        resources {
                          gpus
                          nodes
                          mem
                          storage
                          walltime
                        }
                        progress {
                          n
                          n_expected
                          n_max
                          done
                        }
                      }
                    }
                    pageInfo {
                      hasPreviousPage
                      hasNextPage
                      startCursor
                      endCursor
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "sort": sort,
            "filter": filter,
        }
        response = await self.execute(
            query=query,
            operation_name="module_instances",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ModuleInstances.model_validate(data).me

    async def create_multiple_sequence_alignment(
        self, input: CreateMultipleSequenceAlignment, **kwargs: Any
    ) -> CreateMultipleSequenceAlignmentCreateMsa:
        query = gql(
            """
            mutation create_multiple_sequence_alignment($input: CreateMultipleSequenceAlignment!) {
              create_msa(input: $input) {
                id
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = await self.execute(
            query=query,
            operation_name="create_multiple_sequence_alignment",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateMultipleSequenceAlignment.model_validate(data).create_msa

    async def create_protein_conformer(
        self, protein_conformer: CreateProteinConformer, **kwargs: Any
    ) -> CreateProteinConformerCreateProteinConformer:
        query = gql(
            """
            mutation create_protein_conformer($protein_conformer: CreateProteinConformer!) {
              create_protein_conformer(input: $protein_conformer) {
                id
                residues
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein_conformer": protein_conformer}
        response = await self.execute(
            query=query,
            operation_name="create_protein_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateProteinConformer.model_validate(data).create_protein_conformer

    async def create_protein(
        self, protein: CreateProtein, **kwargs: Any
    ) -> CreateProteinCreateProtein:
        query = gql(
            """
            mutation create_protein($protein: CreateProtein!) {
              create_protein(input: $protein) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein": protein}
        response = await self.execute(
            query=query, operation_name="create_protein", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProtein.model_validate(data).create_protein

    async def argument(self, id: UUID, **kwargs: Any) -> ArgumentArgument:
        query = gql(
            """
            query argument($id: ArgumentId!) {
              argument(id: $id) {
                ...ArgumentFull
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="argument", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Argument.model_validate(data).argument

    async def arguments(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        filter: Union[Optional[ArgumentFilter], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ArgumentsMe:
        query = gql(
            """
            query arguments($after: String, $before: String, $first: Int, $last: Int, $filter: ArgumentFilter) {
              me {
                account {
                  arguments(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    filter: $filter
                  ) {
                    pageInfo {
                      ...PageInfoFull
                    }
                    edges {
                      cursor
                      node {
                        ...ArgumentFull
                      }
                    }
                  }
                }
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "filter": filter,
        }
        response = await self.execute(
            query=query, operation_name="arguments", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Arguments.model_validate(data).me

    async def latest_modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        names: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> LatestModulesLatestModules:
        query = gql(
            """
            query latest_modules($after: String, $before: String, $first: Int, $last: Int, $names: [String!]) {
              latest_modules(
                after: $after
                before: $before
                first: $first
                last: $last
                names: $names
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "names": names,
        }
        response = await self.execute(
            query=query, operation_name="latest_modules", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return LatestModules.model_validate(data).latest_modules

    async def modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        filter: Union[Optional[ModuleFilter], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModulesModules:
        query = gql(
            """
            query modules($after: String, $before: String, $first: Int, $last: Int, $filter: ModuleFilter) {
              modules(
                first: $first
                last: $last
                after: $after
                before: $before
                filter: $filter
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "filter": filter,
        }
        response = await self.execute(
            query=query, operation_name="modules", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Modules.model_validate(data).modules

    async def module_instance_details(
        self,
        id: UUID,
        stderr_after: Union[Optional[str], UnsetType] = UNSET,
        stderr_before: Union[Optional[str], UnsetType] = UNSET,
        stdout_after: Union[Optional[str], UnsetType] = UNSET,
        stdout_before: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstanceDetailsModuleInstance:
        query = gql(
            """
            query module_instance_details($id: ModuleInstanceId!, $stderr_after: String, $stderr_before: String, $stdout_after: String, $stdout_before: String) {
              module_instance(id: $id) {
                ...ModuleInstanceFull
                stdout(after: $stdout_after, before: $stdout_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
                stderr(after: $stderr_after, before: $stderr_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }

            fragment ModuleInstanceFull on ModuleInstance {
              ...ModuleInstanceCommon
              ins {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
                source
              }
              outs {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
                source
              }
              resources {
                gpus
                nodes
                mem
                storage
                walltime
              }
              progress {
                n
                n_expected
                n_max
                done
              }
              resource_utilization {
                gpu
                mem
                storage
                walltime
                cputime
                inodes
                sus
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "id": id,
            "stderr_after": stderr_after,
            "stderr_before": stderr_before,
            "stdout_after": stdout_after,
            "stdout_before": stdout_before,
        }
        response = await self.execute(
            query=query,
            operation_name="module_instance_details",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceDetails.model_validate(data).module_instance

    async def module_instance_minimal(
        self, id: UUID, **kwargs: Any
    ) -> ModuleInstanceMinimalModuleInstance:
        query = gql(
            """
            query module_instance_minimal($id: ModuleInstanceId!) {
              module_instance(id: $id) {
                ...ModuleInstanceCommon
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query,
            operation_name="module_instance_minimal",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceMinimal.model_validate(data).module_instance

    async def object_url(self, path: Any, **kwargs: Any) -> ObjectUrlObjectPath:
        query = gql(
            """
            query object_url($path: UUID!) {
              object_path(path: $path) {
                url
              }
            }
            """
        )
        variables: Dict[str, object] = {"path": path}
        response = await self.execute(
            query=query, operation_name="object_url", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ObjectUrl.model_validate(data).object_path

    async def object_contents(
        self, path: Any, **kwargs: Any
    ) -> ObjectContentsObjectPath:
        query = gql(
            """
            query object_contents($path: UUID!) {
              object_path(path: $path) {
                contents
              }
            }
            """
        )
        variables: Dict[str, object] = {"path": path}
        response = await self.execute(
            query=query, operation_name="object_contents", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ObjectContents.model_validate(data).object_path

    async def smol_libraries(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        sort: Union[Optional[SmolLibrarySort], UnsetType] = UNSET,
        **kwargs: Any
    ) -> SmolLibrariesSmolLibraries:
        query = gql(
            """
            query smol_libraries($after: String, $before: String, $first: Int, $last: Int, $sort: SmolLibrarySort) {
              smol_libraries(
                after: $after
                before: $before
                first: $first
                last: $last
                sort: $sort
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    id
                    name
                    description
                    created_at
                    updated_at
                    deleted_at
                    tags
                  }
                }
                total_count
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "sort": sort,
        }
        response = await self.execute(
            query=query, operation_name="smol_libraries", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SmolLibraries.model_validate(data).smol_libraries

    async def project(self, project_id: Any, **kwargs: Any) -> ProjectMe:
        query = gql(
            """
            query project($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    id
                    created_at
                    updated_at
                    deleted_at
                    name
                    description
                    run_id
                    tags
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="project", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Project.model_validate(data).me

    async def projects(self, **kwargs: Any) -> ProjectsMe:
        query = gql(
            """
            query projects {
              me {
                account {
                  projects {
                    pageInfo {
                      ...PageInfoFull
                    }
                    edges {
                      cursor
                      node {
                        id
                        created_at
                        updated_at
                        deleted_at
                        name
                        description
                        run_id
                        tags
                      }
                    }
                    total_count
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=query, operation_name="projects", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Projects.model_validate(data).me

    async def run(self, project_id: Any, run_id: Any, **kwargs: Any) -> RunMe:
        query = gql(
            """
            query run($project_id: ProjectId!, $run_id: RunId!) {
              me {
                account {
                  project(id: $project_id) {
                    run(id: $run_id) {
                      id
                      rex
                      result
                      trace
                      module_lock
                      status
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "run_id": run_id}
        response = await self.execute(
            query=query, operation_name="run", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Run.model_validate(data).me

    async def runs(self, project_id: Any, **kwargs: Any) -> RunsMe:
        query = gql(
            """
            query runs($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    runs {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          rex
                          result
                          trace
                          module_lock
                          status
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="runs", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Runs.model_validate(data).me

    async def protein(
        self, project_id: Any, protein_id: Any, **kwargs: Any
    ) -> ProteinMe:
        query = gql(
            """
            query protein($project_id: ProjectId!, $protein_id: ProteinId!) {
              me {
                account {
                  project(id: $project_id) {
                    protein(id: $protein_id) {
                      id
                      sequence
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "project_id": project_id,
            "protein_id": protein_id,
        }
        response = await self.execute(
            query=query, operation_name="protein", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Protein.model_validate(data).me

    async def proteins(self, project_id: Any, **kwargs: Any) -> ProteinsMe:
        query = gql(
            """
            query proteins($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    proteins {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          sequence
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="proteins", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Proteins.model_validate(data).me

    async def smol(self, project_id: Any, smol_id: Any, **kwargs: Any) -> SmolMe:
        query = gql(
            """
            query smol($project_id: ProjectId!, $smol_id: SmolId!) {
              me {
                account {
                  project(id: $project_id) {
                    smol(id: $smol_id) {
                      id
                      smi
                      inchi
                      data_blocks
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "smol_id": smol_id}
        response = await self.execute(
            query=query, operation_name="smol", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Smol.model_validate(data).me

    async def smols(self, project_id: Any, **kwargs: Any) -> SmolsMe:
        query = gql(
            """
            query smols($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    smols {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          smi
                          inchi
                          data_blocks
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="smols", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Smols.model_validate(data).me

    async def msa(self, project_id: Any, msa_id: Any, **kwargs: Any) -> MsaMe:
        query = gql(
            """
            query msa($project_id: ProjectId!, $msa_id: MultipleSequenceAlignmentId!) {
              me {
                account {
                  project(id: $project_id) {
                    msa(id: $msa_id) {
                      id
                      a_3m
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "msa_id": msa_id}
        response = await self.execute(
            query=query, operation_name="msa", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Msa.model_validate(data).me

    async def msas(self, project_id: Any, **kwargs: Any) -> MsasMe:
        query = gql(
            """
            query msas($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    msas {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          a_3m
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="msas", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Msas.model_validate(data).me

    async def structure(
        self, project_id: Any, structure_id: Any, **kwargs: Any
    ) -> StructureMe:
        query = gql(
            """
            query structure($project_id: ProjectId!, $structure_id: StructureId!) {
              me {
                account {
                  project(id: $project_id) {
                    structure(id: $structure_id) {
                      id
                      rcsb_id
                      topology
                      residues
                      chains
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "project_id": project_id,
            "structure_id": structure_id,
        }
        response = await self.execute(
            query=query, operation_name="structure", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Structure.model_validate(data).me

    async def structures(self, project_id: Any, **kwargs: Any) -> StructuresMe:
        query = gql(
            """
            query structures($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    structures {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          rcsb_id
                          topology
                          residues
                          chains
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="structures", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Structures.model_validate(data).me

    async def protein_conformer(
        self, project_id: Any, conformer_id: Any, **kwargs: Any
    ) -> ProteinConformerMe:
        query = gql(
            """
            query protein_conformer($project_id: ProjectId!, $conformer_id: ProteinConformerId!) {
              me {
                account {
                  project(id: $project_id) {
                    protein_conformer(id: $conformer_id) {
                      id
                      residues
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      structure {
                        id
                        rcsb_id
                      }
                      protein {
                        id
                        sequence
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "project_id": project_id,
            "conformer_id": conformer_id,
        }
        response = await self.execute(
            query=query,
            operation_name="protein_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ProteinConformer.model_validate(data).me

    async def protein_conformers(
        self, project_id: Any, **kwargs: Any
    ) -> ProteinConformersMe:
        query = gql(
            """
            query protein_conformers($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    protein_conformers {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          residues
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          structure {
                            id
                            rcsb_id
                          }
                          protein {
                            id
                            sequence
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="protein_conformers",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ProteinConformers.model_validate(data).me

    async def smol_conformer(
        self, project_id: Any, conformer_id: Any, **kwargs: Any
    ) -> SmolConformerMe:
        query = gql(
            """
            query smol_conformer($project_id: ProjectId!, $conformer_id: SmolConformerId!) {
              me {
                account {
                  project(id: $project_id) {
                    smol_conformer(id: $conformer_id) {
                      id
                      residues
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      structure {
                        id
                        rcsb_id
                      }
                      smol {
                        id
                        smi
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "project_id": project_id,
            "conformer_id": conformer_id,
        }
        response = await self.execute(
            query=query, operation_name="smol_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SmolConformer.model_validate(data).me

    async def smol_conformers(self, project_id: Any, **kwargs: Any) -> SmolConformersMe:
        query = gql(
            """
            query smol_conformers($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    smol_conformers {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          residues
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          structure {
                            id
                            rcsb_id
                          }
                          smol {
                            id
                            smi
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query, operation_name="smol_conformers", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SmolConformers.model_validate(data).me

    async def binding_site_interaction(
        self, project_id: Any, bsi_id: Any, **kwargs: Any
    ) -> BindingSiteInteractionMe:
        query = gql(
            """
            query binding_site_interaction($project_id: ProjectId!, $bsi_id: BindingSiteInteractionsId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_site_interaction(id: $bsi_id) {
                      id
                      residues
                      interactions {
                        kind
                        pi_stack_kind
                        ligand_atom
                        receptor_atom
                      }
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "bsi_id": bsi_id}
        response = await self.execute(
            query=query,
            operation_name="binding_site_interaction",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingSiteInteraction.model_validate(data).me

    async def binding_site_interactions(
        self, project_id: Any, **kwargs: Any
    ) -> BindingSiteInteractionsMe:
        query = gql(
            """
            query binding_site_interactions($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_site_interactions {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          residues
                          interactions {
                            kind
                            pi_stack_kind
                            ligand_atom
                            receptor_atom
                          }
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="binding_site_interactions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingSiteInteractions.model_validate(data).me

    async def binding_site_conformer(
        self, project_id: Any, bsc_id: Any, **kwargs: Any
    ) -> BindingSiteConformerMe:
        query = gql(
            """
            query binding_site_conformer($project_id: ProjectId!, $bsc_id: BindingSiteConformerId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_site_conformer(id: $bsc_id) {
                      id
                      bounding_box {
                        min
                        max
                      }
                      surface_atoms
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      protein_conformer {
                        id
                        residues
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "bsc_id": bsc_id}
        response = await self.execute(
            query=query,
            operation_name="binding_site_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingSiteConformer.model_validate(data).me

    async def binding_site_conformers(
        self, project_id: Any, **kwargs: Any
    ) -> BindingSiteConformersMe:
        query = gql(
            """
            query binding_site_conformers($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_site_conformers {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          bounding_box {
                            min
                            max
                          }
                          surface_atoms
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          protein_conformer {
                            id
                            residues
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="binding_site_conformers",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingSiteConformers.model_validate(data).me

    async def binding_pose_conformer(
        self, project_id: Any, bpc_id: Any, **kwargs: Any
    ) -> BindingPoseConformerMe:
        query = gql(
            """
            query binding_pose_conformer($project_id: ProjectId!, $bpc_id: BindingPoseConformerId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_pose_conformer(id: $bpc_id) {
                      id
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      smol_conformer {
                        id
                        residues
                      }
                      binding_site_conformer {
                        id
                        bounding_box {
                          min
                          max
                        }
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "bpc_id": bpc_id}
        response = await self.execute(
            query=query,
            operation_name="binding_pose_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingPoseConformer.model_validate(data).me

    async def binding_pose_conformers(
        self, project_id: Any, **kwargs: Any
    ) -> BindingPoseConformersMe:
        query = gql(
            """
            query binding_pose_conformers($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_pose_conformers {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          smol_conformer {
                            id
                            residues
                          }
                          binding_site_conformer {
                            id
                            bounding_box {
                              min
                              max
                            }
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="binding_pose_conformers",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingPoseConformers.model_validate(data).me

    async def binding_affinity(
        self, project_id: Any, ba_id: Any, **kwargs: Any
    ) -> BindingAffinityMe:
        query = gql(
            """
            query binding_affinity($project_id: ProjectId!, $ba_id: BindingAffinityId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_affinity(id: $ba_id) {
                      id
                      affinity
                      affinity_metric
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      protein {
                        id
                        sequence
                      }
                      smol {
                        id
                        smi
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "ba_id": ba_id}
        response = await self.execute(
            query=query,
            operation_name="binding_affinity",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingAffinity.model_validate(data).me

    async def binding_affinities(
        self, project_id: Any, **kwargs: Any
    ) -> BindingAffinitiesMe:
        query = gql(
            """
            query binding_affinities($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_affinities {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          affinity
                          affinity_metric
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          protein {
                            id
                            sequence
                          }
                          smol {
                            id
                            smi
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="binding_affinities",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingAffinities.model_validate(data).me

    async def binding_pose_conformer_interaction(
        self, project_id: Any, bpci_id: Any, **kwargs: Any
    ) -> BindingPoseConformerInteractionMe:
        query = gql(
            """
            query binding_pose_conformer_interaction($project_id: ProjectId!, $bpci_id: BindingPoseConformerInteractionsId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_pose_conformer_interaction(id: $bpci_id) {
                      id
                      created_at
                      updated_at
                      deleted_at
                      name
                      description
                      run_id
                      tags
                      binding_pose_conformer {
                        id
                      }
                      binding_site_interactions {
                        id
                        residues
                        interactions {
                          kind
                          pi_stack_kind
                          ligand_atom
                          receptor_atom
                        }
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id, "bpci_id": bpci_id}
        response = await self.execute(
            query=query,
            operation_name="binding_pose_conformer_interaction",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingPoseConformerInteraction.model_validate(data).me

    async def binding_pose_conformer_interactions(
        self, project_id: Any, **kwargs: Any
    ) -> BindingPoseConformerInteractionsMe:
        query = gql(
            """
            query binding_pose_conformer_interactions($project_id: ProjectId!) {
              me {
                account {
                  project(id: $project_id) {
                    binding_pose_conformer_interactions {
                      pageInfo {
                        ...PageInfoFull
                      }
                      edges {
                        cursor
                        node {
                          id
                          created_at
                          updated_at
                          deleted_at
                          name
                          description
                          run_id
                          tags
                          binding_pose_conformer {
                            id
                          }
                          binding_site_interactions {
                            id
                            residues
                            interactions {
                              kind
                              pi_stack_kind
                              ligand_atom
                              receptor_atom
                            }
                          }
                        }
                      }
                      total_count
                    }
                  }
                }
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {"project_id": project_id}
        response = await self.execute(
            query=query,
            operation_name="binding_pose_conformer_interactions",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return BindingPoseConformerInteractions.model_validate(data).me

    async def retry(
        self,
        instance: UUID,
        target: ModuleInstanceTarget,
        resources: Union[Optional[ResourcesInput], UnsetType] = UNSET,
        **kwargs: Any
    ) -> RetryRetry:
        query = gql(
            """
            mutation retry($instance: ModuleInstanceId!, $target: ModuleInstanceTarget!, $resources: ResourcesInput) {
              retry(instance: $instance, target: $target, resources: $resources) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "instance": instance,
            "target": target,
            "resources": resources,
        }
        response = await self.execute(
            query=query, operation_name="retry", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Retry.model_validate(data).retry

    async def run_module(
        self, instance: CreateModuleInstance, **kwargs: Any
    ) -> RunModuleRun:
        query = gql(
            """
            mutation run_module($instance: CreateModuleInstance!) {
              run(instance: $instance) {
                id
                outs {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"instance": instance}
        response = await self.execute(
            query=query, operation_name="run_module", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return RunModule.model_validate(data).run

    async def create_smol_conformer(
        self, smol_conformer: CreateSmolConformer, **kwargs: Any
    ) -> CreateSmolConformerCreateSmolConformer:
        query = gql(
            """
            mutation create_smol_conformer($smol_conformer: CreateSmolConformer!) {
              create_smol_conformer(input: $smol_conformer) {
                id
                residues
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol_conformer": smol_conformer}
        response = await self.execute(
            query=query,
            operation_name="create_smol_conformer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSmolConformer.model_validate(data).create_smol_conformer

    async def create_smol(
        self, smol: CreateSmol, **kwargs: Any
    ) -> CreateSmolCreateSmol:
        query = gql(
            """
            mutation create_smol($smol: CreateSmol!) {
              create_smol(input: $smol) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol": smol}
        response = await self.execute(
            query=query, operation_name="create_smol", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmol.model_validate(data).create_smol

    async def create_smol_library(
        self, smol_library: CreateSmolLibrary, **kwargs: Any
    ) -> CreateSmolLibraryCreateSmolLibrary:
        query = gql(
            """
            mutation create_smol_library($smol_library: CreateSmolLibrary!) {
              create_smol_library(input: $smol_library) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol_library": smol_library}
        response = await self.execute(
            query=query,
            operation_name="create_smol_library",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSmolLibrary.model_validate(data).create_smol_library

    async def create_smol_library_partition(
        self, smol_library_partition: CreateSmolLibraryPartition, **kwargs: Any
    ) -> CreateSmolLibraryPartitionCreateSmolLibraryPartition:
        query = gql(
            """
            mutation create_smol_library_partition($smol_library_partition: CreateSmolLibraryPartition!) {
              create_smol_library_partition(input: $smol_library_partition) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "smol_library_partition": smol_library_partition
        }
        response = await self.execute(
            query=query,
            operation_name="create_smol_library_partition",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateSmolLibraryPartition.model_validate(
            data
        ).create_smol_library_partition

    async def create_structure(
        self, structure: CreateStructure, **kwargs: Any
    ) -> CreateStructureCreateStructure:
        query = gql(
            """
            mutation create_structure($structure: CreateStructure!) {
              create_structure(input: $structure) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"structure": structure}
        response = await self.execute(
            query=query,
            operation_name="create_structure",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateStructure.model_validate(data).create_structure

    async def create_tag(self, tag: CreateTag, **kwargs: Any) -> CreateTagCreateTag:
        query = gql(
            """
            mutation create_tag($tag: CreateTag!) {
              create_tag(input: $tag) {
                id
                key
                value
                tagged_id
                tagged_type
                name
                description
                tags
              }
            }
            """
        )
        variables: Dict[str, object] = {"tag": tag}
        response = await self.execute(
            query=query, operation_name="create_tag", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateTag.model_validate(data).create_tag

    async def tag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation tag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              tag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(
            query=query, operation_name="tag", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Tag.model_validate(data).tag

    async def track_utilization(
        self, utilization: CreateResourceUtilization, **kwargs: Any
    ) -> TrackUtilizationTrackModuleInstanceResourceUtilization:
        query = gql(
            """
            mutation track_utilization($utilization: CreateResourceUtilization!) {
              track_module_instance_resource_utilization(utilization: $utilization) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"utilization": utilization}
        response = await self.execute(
            query=query,
            operation_name="track_utilization",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return TrackUtilization.model_validate(
            data
        ).track_module_instance_resource_utilization

    async def untag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation untag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              untag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(
            query=query, operation_name="untag", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return Untag.model_validate(data).untag

    async def update_account_config(
        self, account_id: UUID, input: AccountConfigInput, **kwargs: Any
    ) -> UpdateAccountConfigUpdateAccountConfig:
        query = gql(
            """
            mutation update_account_config($account_id: AccountId!, $input: AccountConfigInput!) {
              update_account_config(account_id: $account_id, input: $input) {
                config_account
                bucket_config {
                  data_bucket
                  log_bucket
                  bucket_region
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"account_id": account_id, "input": input}
        response = await self.execute(
            query=query,
            operation_name="update_account_config",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateAccountConfig.model_validate(data).update_account_config

    async def update_account_tier(
        self, account_id: UUID, tier: AccountTier, **kwargs: Any
    ) -> AccountTier:
        query = gql(
            """
            mutation update_account_tier($account_id: AccountId!, $tier: AccountTier!) {
              update_account_tier(account_id: $account_id, tier: $tier)
            }
            """
        )
        variables: Dict[str, object] = {"account_id": account_id, "tier": tier}
        response = await self.execute(
            query=query,
            operation_name="update_account_tier",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateAccountTier.model_validate(data).update_account_tier

    async def update_module_instance(
        self,
        id: UUID,
        module_instance_update: PatchModuleInstanceInput,
        arguments: Union[Optional[List[ArgumentInput]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> UpdateModuleInstanceUpdateModuleInstance:
        query = gql(
            """
            mutation update_module_instance($id: ModuleInstanceId!, $moduleInstanceUpdate: PatchModuleInstanceInput!, $arguments: [ArgumentInput!]) {
              update_module_instance(
                arguments_update: $arguments
                instance_id: $id
                instance_update: $moduleInstanceUpdate
              ) {
                id
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "id": id,
            "moduleInstanceUpdate": module_instance_update,
            "arguments": arguments,
        }
        response = await self.execute(
            query=query,
            operation_name="update_module_instance",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateModuleInstance.model_validate(data).update_module_instance

    async def upload_large_object(
        self,
        typeinfo: Any,
        format: ObjectFormat,
        public: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> UploadLargeObjectUploadLargeObject:
        query = gql(
            """
            mutation upload_large_object($typeinfo: JSON!, $format: ObjectFormat!, $public: Boolean) {
              upload_large_object(typeinfo: $typeinfo, format: $format, public: $public) {
                upload_url
                descriptor {
                  id
                  name
                  description
                  type_info
                  object {
                    format
                    size
                    path
                  }
                  tags
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "typeinfo": typeinfo,
            "format": format,
            "public": public,
        }
        response = await self.execute(
            query=query,
            operation_name="upload_large_object",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UploadLargeObject.model_validate(data).upload_large_object
