# Generated by ariadne-codegen
# Source: combined.graphql

from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from .argument import Argument, ArgumentArgument
from .arguments import Arguments, ArgumentsMe
from .async_base_client import AsyncBaseClient
from .base_model import UNSET, UnsetType
from .cancel_module_instance import CancelModuleInstance
from .create_project import CreateProject, CreateProjectCreateProject
from .create_protein import CreateProtein, CreateProteinCreateProtein
from .create_protein_conformer import (
    CreateProteinConformer,
    CreateProteinConformerCreateProteinConformer,
)
from .create_smol import CreateSmol, CreateSmolCreateSmol
from .create_smol_conformer import (
    CreateSmolConformer,
    CreateSmolConformerCreateSmolConformer,
)
from .create_structure import CreateStructure, CreateStructureCreateStructure
from .delete_module_instance import (
    DeleteModuleInstance,
    DeleteModuleInstanceDeleteModuleInstance,
)
from .deploy import Deploy, DeployDeploy
from .enums import ModuleInstanceStatus, ModuleInstanceTarget, ObjectFormat, OrderBy
from .input_types import (
    CreateProjectInput,
    CreateProteinConformerInput,
    CreateProteinInput,
    CreateSmolConformerInput,
    CreateSmolInput,
    CreateStructureInput,
    ModuleInput,
    ModuleInstanceInput,
    ModuleInstanceResourcesInput,
    ResourceUtilizationInput,
    TypeQuery,
    UpdateModuleInstanceInput,
)
from .latest_modules import LatestModules, LatestModulesLatestModules
from .module_instance_details import (
    ModuleInstanceDetails,
    ModuleInstanceDetailsModuleInstance,
)
from .module_instance_minimal import (
    ModuleInstanceMinimal,
    ModuleInstanceMinimalModuleInstance,
)
from .module_instances import ModuleInstances, ModuleInstancesMe
from .modules import Modules, ModulesModules
from .object_contents import ObjectContents, ObjectContentsObjectPath
from .object_url import ObjectUrl, ObjectUrlObjectPath
from .retry import Retry, RetryRetry
from .run import Run, RunRun
from .tag import Tag
from .track_utilization import (
    TrackUtilization,
    TrackUtilizationTrackModuleInstanceResourceUtilization,
)
from .untag import Untag
from .update_module_instance import (
    UpdateModuleInstance,
    UpdateModuleInstanceUpdateModuleInstance,
)
from .upload_large_object import UploadLargeObject, UploadLargeObjectUploadLargeObject


def gql(q: str) -> str:
    return q


class Client(AsyncBaseClient):
    async def cancel_module_instance(self, module_instance_id: UUID, **kwargs: Any) -> UUID:
        query = gql(
            """
            mutation cancel_module_instance($moduleInstanceId: ModuleInstanceId!) {
              cancel(instance: $moduleInstanceId)
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query, operation_name="cancel_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CancelModuleInstance.model_validate(data).cancel

    async def delete_module_instance(
        self, module_instance_id: UUID, **kwargs: Any
    ) -> DeleteModuleInstanceDeleteModuleInstance:
        query = gql(
            """
            mutation delete_module_instance($moduleInstanceId: ModuleInstanceId!) {
              delete_module_instance(module: $moduleInstanceId) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceId": module_instance_id}
        response = await self.execute(
            query=query, operation_name="delete_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return DeleteModuleInstance.model_validate(data).delete_module_instance

    async def deploy(self, module: ModuleInput, **kwargs: Any) -> DeployDeploy:
        query = gql(
            """
            mutation deploy($module: ModuleInput!) {
              deploy(module: $module) {
                id
                path
              }
            }
            """
        )
        variables: Dict[str, object] = {"module": module}
        response = await self.execute(query=query, operation_name="deploy", variables=variables, **kwargs)
        data = self.get_data(response)
        return Deploy.model_validate(data).deploy

    async def module_instances(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        path: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        status: Union[Optional[ModuleInstanceStatus], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        ids: Union[Optional[List[UUID]], UnsetType] = UNSET,
        in_argument_ids: Union[Optional[List[UUID]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstancesMe:
        query = gql(
            """
            query module_instances($after: String, $before: String, $first: Int, $last: Int, $path: String, $name: String, $status: ModuleInstanceStatus, $tags: [String!], $ids: [ModuleInstanceId!], $in_argument_ids: [ArgumentId!]) {
              me {
                account {
                  module_instances(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    path: $path
                    status: $status
                    name: $name
                    tags: $tags
                    ids: $ids
                    in_arguments: $in_argument_ids
                  ) {
                    edges {
                      cursor
                      node {
                        id
                        account_id
                        created_at
                        deleted_at
                        queued_at
                        admitted_at
                        dispatched_at
                        completed_at
                        path
                        status
                        target
                        tags
                        ins {
                          id
                          created_at
                          deleted_at
                          rejected_at
                          account_id
                          typeinfo
                          value
                          tags
                          source
                        }
                        outs {
                          id
                          created_at
                          deleted_at
                          rejected_at
                          account_id
                          typeinfo
                          value
                          tags
                          source
                        }
                        resources {
                          gpus
                          nodes
                          mem
                          storage
                          walltime
                        }
                        progress {
                          n
                          n_expected
                          n_max
                          done
                        }
                      }
                    }
                    pageInfo {
                      hasPreviousPage
                      hasNextPage
                      startCursor
                      endCursor
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "path": path,
            "name": name,
            "status": status,
            "tags": tags,
            "ids": ids,
            "in_argument_ids": in_argument_ids,
        }
        response = await self.execute(
            query=query, operation_name="module_instances", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstances.model_validate(data).me

    async def create_project(self, project: CreateProjectInput, **kwargs: Any) -> CreateProjectCreateProject:
        query = gql(
            """
            mutation create_project($project: CreateProjectInput!) {
              create_project(input: $project) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"project": project}
        response = await self.execute(
            query=query, operation_name="create_project", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProject.model_validate(data).create_project

    async def create_protein_conformer(
        self, protein_conformer: CreateProteinConformerInput, **kwargs: Any
    ) -> CreateProteinConformerCreateProteinConformer:
        query = gql(
            """
            mutation create_protein_conformer($protein_conformer: CreateProteinConformerInput!) {
              create_protein_conformer(input: $protein_conformer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein_conformer": protein_conformer}
        response = await self.execute(
            query=query, operation_name="create_protein_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProteinConformer.model_validate(data).create_protein_conformer

    async def create_protein(self, protein: CreateProteinInput, **kwargs: Any) -> CreateProteinCreateProtein:
        query = gql(
            """
            mutation create_protein($protein: CreateProteinInput!) {
              create_protein(input: $protein) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"protein": protein}
        response = await self.execute(
            query=query, operation_name="create_protein", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateProtein.model_validate(data).create_protein

    async def argument(self, id: UUID, **kwargs: Any) -> ArgumentArgument:
        query = gql(
            """
            query argument($id: ArgumentId!) {
              argument(id: $id) {
                ...ArgumentFull
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(query=query, operation_name="argument", variables=variables, **kwargs)
        data = self.get_data(response)
        return Argument.model_validate(data).argument

    async def arguments(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        typeinfo: Union[Optional[List[Any]], UnsetType] = UNSET,
        typequery: Union[Optional[List[TypeQuery]], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        resolved: Union[Optional[bool], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ArgumentsMe:
        query = gql(
            """
            query arguments($after: String, $before: String, $first: Int, $last: Int, $typeinfo: [Type!], $typequery: [TypeQuery!], $tags: [String!], $resolved: Boolean) {
              me {
                account {
                  arguments(
                    first: $first
                    last: $last
                    after: $after
                    before: $before
                    typeinfo: $typeinfo
                    typequery: $typequery
                    tags: $tags
                    resolved: $resolved
                  ) {
                    pageInfo {
                      ...PageInfoFull
                    }
                    edges {
                      cursor
                      node {
                        ...ArgumentFull
                      }
                    }
                  }
                }
              }
            }

            fragment ArgumentFull on Argument {
              id
              name
              typeinfo
              value
              created_at
              rejected_at
              source
              tags
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "typeinfo": typeinfo,
            "typequery": typequery,
            "tags": tags,
            "resolved": resolved,
        }
        response = await self.execute(query=query, operation_name="arguments", variables=variables, **kwargs)
        data = self.get_data(response)
        return Arguments.model_validate(data).me

    async def latest_modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        order: Union[Optional[OrderBy], UnsetType] = UNSET,
        names: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> LatestModulesLatestModules:
        query = gql(
            """
            query latest_modules($after: String, $before: String, $first: Int, $last: Int, $order: OrderBy, $names: [String!]) {
              latest_modules(
                after: $after
                before: $before
                first: $first
                last: $last
                order: $order
                names: $names
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              usage
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "order": order,
            "names": names,
        }
        response = await self.execute(
            query=query, operation_name="latest_modules", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return LatestModules.model_validate(data).latest_modules

    async def modules(
        self,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        path: Union[Optional[str], UnsetType] = UNSET,
        tags: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModulesModules:
        query = gql(
            """
            query modules($after: String, $before: String, $first: Int, $last: Int, $path: String, $tags: [String!]) {
              modules(
                first: $first
                last: $last
                after: $after
                before: $before
                path: $path
                tags: $tags
              ) {
                pageInfo {
                  ...PageInfoFull
                }
                edges {
                  cursor
                  node {
                    ...ModuleFull
                  }
                }
              }
            }

            fragment ModuleFull on Module {
              id
              name
              created_at
              deleted_at
              path
              usage
              ins
              ins_usage
              outs
              outs_usage
              description
              typedesc
              tags
              targets
              resource_bounds {
                gpu_min
                gpu_max
                gpu_hint
                gpu_mem_min
                gpu_mem_max
                gpu_mem_hint
                cpu_min
                cpu_max
                cpu_hint
                node_min
                node_max
                node_hint
                mem_min
                mem_max
                storage_min
                storage_max
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "after": after,
            "before": before,
            "first": first,
            "last": last,
            "path": path,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="modules", variables=variables, **kwargs)
        data = self.get_data(response)
        return Modules.model_validate(data).modules

    async def module_instance_details(
        self,
        id: UUID,
        stderr_after: Union[Optional[str], UnsetType] = UNSET,
        stderr_before: Union[Optional[str], UnsetType] = UNSET,
        stdout_after: Union[Optional[str], UnsetType] = UNSET,
        stdout_before: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ModuleInstanceDetailsModuleInstance:
        query = gql(
            """
            query module_instance_details($id: ModuleInstanceId!, $stderr_after: String, $stderr_before: String, $stdout_after: String, $stdout_before: String) {
              module_instance(id: $id) {
                ...ModuleInstanceFull
                stdout(after: $stdout_after, before: $stdout_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
                stderr(after: $stderr_after, before: $stderr_before) {
                  pageInfo {
                    ...PageInfoFull
                  }
                  edges {
                    cursor
                    node {
                      id
                      created_at
                      content
                    }
                  }
                }
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }

            fragment ModuleInstanceFull on ModuleInstance {
              ...ModuleInstanceCommon
              ins {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
                source
              }
              outs {
                id
                created_at
                deleted_at
                rejected_at
                account_id
                typeinfo
                value
                tags
                source
              }
              resources {
                gpus
                nodes
                mem
                storage
                walltime
              }
              progress {
                n
                n_expected
                n_max
                done
              }
              resource_utilization {
                gpu
                mem
                storage
                walltime
                cputime
                inodes
                sus
              }
            }

            fragment PageInfoFull on PageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            """
        )
        variables: Dict[str, object] = {
            "id": id,
            "stderr_after": stderr_after,
            "stderr_before": stderr_before,
            "stdout_after": stdout_after,
            "stdout_before": stdout_before,
        }
        response = await self.execute(
            query=query, operation_name="module_instance_details", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceDetails.model_validate(data).module_instance

    async def module_instance_minimal(self, id: UUID, **kwargs: Any) -> ModuleInstanceMinimalModuleInstance:
        query = gql(
            """
            query module_instance_minimal($id: ModuleInstanceId!) {
              module_instance(id: $id) {
                ...ModuleInstanceCommon
              }
            }

            fragment ModuleInstanceCommon on ModuleInstance {
              id
              account_id
              name
              created_at
              deleted_at
              queued_at
              admitted_at
              dispatched_at
              completed_at
              path
              status
              target
              tags
              failure_reason
              failure_context {
                stdout
                stderr
                syserr
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="module_instance_minimal", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ModuleInstanceMinimal.model_validate(data).module_instance

    async def object_url(self, path: Any, **kwargs: Any) -> ObjectUrlObjectPath:
        query = gql(
            """
            query object_url($path: UUID!) {
              object_path(path: $path) {
                url
              }
            }
            """
        )
        variables: Dict[str, object] = {"path": path}
        response = await self.execute(query=query, operation_name="object_url", variables=variables, **kwargs)
        data = self.get_data(response)
        return ObjectUrl.model_validate(data).object_path

    async def object_contents(self, path: Any, **kwargs: Any) -> ObjectContentsObjectPath:
        query = gql(
            """
            query object_contents($path: UUID!) {
              object_path(path: $path) {
                contents
              }
            }
            """
        )
        variables: Dict[str, object] = {"path": path}
        response = await self.execute(
            query=query, operation_name="object_contents", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ObjectContents.model_validate(data).object_path

    async def retry(
        self,
        instance: UUID,
        target: ModuleInstanceTarget,
        resources: Union[Optional[ModuleInstanceResourcesInput], UnsetType] = UNSET,
        **kwargs: Any
    ) -> RetryRetry:
        query = gql(
            """
            mutation retry($instance: ModuleInstanceId!, $target: ModuleInstanceTarget!, $resources: ModuleInstanceResourcesInput) {
              retry(instance: $instance, target: $target, resources: $resources) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "instance": instance,
            "target": target,
            "resources": resources,
        }
        response = await self.execute(query=query, operation_name="retry", variables=variables, **kwargs)
        data = self.get_data(response)
        return Retry.model_validate(data).retry

    async def run(self, instance: ModuleInstanceInput, **kwargs: Any) -> RunRun:
        query = gql(
            """
            mutation run($instance: ModuleInstanceInput!) {
              run(instance: $instance) {
                id
                outs {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"instance": instance}
        response = await self.execute(query=query, operation_name="run", variables=variables, **kwargs)
        data = self.get_data(response)
        return Run.model_validate(data).run

    async def create_smol_conformer(
        self, smol_conformer: CreateSmolConformerInput, **kwargs: Any
    ) -> CreateSmolConformerCreateSmolConformer:
        query = gql(
            """
            mutation create_smol_conformer($smol_conformer: CreateSmolConformerInput!) {
              create_smol_conformer(input: $smol_conformer) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol_conformer": smol_conformer}
        response = await self.execute(
            query=query, operation_name="create_smol_conformer", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmolConformer.model_validate(data).create_smol_conformer

    async def create_smol(self, smol: CreateSmolInput, **kwargs: Any) -> CreateSmolCreateSmol:
        query = gql(
            """
            mutation create_smol($smol: CreateSmolInput!) {
              create_smol(input: $smol) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"smol": smol}
        response = await self.execute(
            query=query, operation_name="create_smol", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateSmol.model_validate(data).create_smol

    async def create_structure(
        self, structure: CreateStructureInput, **kwargs: Any
    ) -> CreateStructureCreateStructure:
        query = gql(
            """
            mutation create_structure($structure: CreateStructureInput!) {
              create_structure(input: $structure) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"structure": structure}
        response = await self.execute(
            query=query, operation_name="create_structure", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateStructure.model_validate(data).create_structure

    async def tag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation tag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              tag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="tag", variables=variables, **kwargs)
        data = self.get_data(response)
        return Tag.model_validate(data).tag

    async def track_utilization(
        self, utilization: ResourceUtilizationInput, **kwargs: Any
    ) -> TrackUtilizationTrackModuleInstanceResourceUtilization:
        query = gql(
            """
            mutation track_utilization($utilization: ResourceUtilizationInput!) {
              track_module_instance_resource_utilization(utilization: $utilization) {
                id
              }
            }
            """
        )
        variables: Dict[str, object] = {"utilization": utilization}
        response = await self.execute(
            query=query, operation_name="track_utilization", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return TrackUtilization.model_validate(data).track_module_instance_resource_utilization

    async def untag(
        self,
        tags: List[str],
        module_instance_id: Union[Optional[UUID], UnsetType] = UNSET,
        argument_id: Union[Optional[UUID], UnsetType] = UNSET,
        module_id: Union[Optional[UUID], UnsetType] = UNSET,
        **kwargs: Any
    ) -> List[str]:
        query = gql(
            """
            mutation untag($moduleInstanceId: ModuleInstanceId, $argumentId: ArgumentId, $moduleId: ModuleId, $tags: [String!]!) {
              untag(
                module_instance: $moduleInstanceId
                argument: $argumentId
                module: $moduleId
                tags: $tags
              )
            }
            """
        )
        variables: Dict[str, object] = {
            "moduleInstanceId": module_instance_id,
            "argumentId": argument_id,
            "moduleId": module_id,
            "tags": tags,
        }
        response = await self.execute(query=query, operation_name="untag", variables=variables, **kwargs)
        data = self.get_data(response)
        return Untag.model_validate(data).untag

    async def update_module_instance(
        self, module_instance_update: UpdateModuleInstanceInput, **kwargs: Any
    ) -> UpdateModuleInstanceUpdateModuleInstance:
        query = gql(
            """
            mutation update_module_instance($moduleInstanceUpdate: UpdateModuleInstanceInput!) {
              update_module_instance(instance_update: $moduleInstanceUpdate) {
                id
                status
              }
            }
            """
        )
        variables: Dict[str, object] = {"moduleInstanceUpdate": module_instance_update}
        response = await self.execute(
            query=query, operation_name="update_module_instance", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UpdateModuleInstance.model_validate(data).update_module_instance

    async def upload_large_object(
        self, typeinfo: Any, format: ObjectFormat, **kwargs: Any
    ) -> UploadLargeObjectUploadLargeObject:
        query = gql(
            """
            mutation upload_large_object($typeinfo: JSON!, $format: ObjectFormat!) {
              upload_large_object(typeinfo: $typeinfo, format: $format) {
                upload_url
                descriptor {
                  id
                  name
                  description
                  type_info
                  object {
                    format
                    size
                    path
                  }
                  tags
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"typeinfo": typeinfo, "format": format}
        response = await self.execute(
            query=query, operation_name="upload_large_object", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UploadLargeObject.model_validate(data).upload_large_object
